{"version":"https://jsonfeed.org/version/1","title":"Smallweb Blog","home_page_url":"http://localhost/","feed_url":"http://localhost/feed.json","description":"The latest new from Smallweb","items":[{"id":"http://localhost/posts/v0.13/","url":"http://localhost/posts/v0.13/","title":"Smallweb 0.13 - Private Apps, Terminal, WebDAV, and CLI entrypoints","content_html":"<p>Hey, It's been a while since the last release of smallweb! I've been taking a break for the month of August, but I'm back with the biggest smallweb release yet, including:</p>\n<ul>\n<li>Protecting private apps with authentication</li>\n<li>Built-in terminal and WebDAV services</li>\n<li>CLI entrypoints</li>\n</ul>\n<!-- more -->\n<h2 id=\"private-apps\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.13/#private-apps\" class=\"header-anchor\">Private Apps</a></h2>\n<p>Smallweb now supports token based authentication for private apps. Enabling it is simple:</p>\n<ol>\n<li>\n<p>Add the some field to the global config (located at <code>~/.config/smallweb/config.json</code>)</p>\n<pre><code class=\"language-json\">{\n    &quot;email&quot;: &quot;pomdtr@smallweb.dev&quot;\n}\n</code></pre>\n<p>You can easily generate a new token with the <code>smallweb token</code> command.</p>\n</li>\n<li>\n<p>Set the <code>private</code> field to true in your app config.</p>\n<pre><code class=\"language-json\">// ~/smallweb/example-app/smallweb.json\n{\n    &quot;private&quot;: true\n}\n</code></pre>\n</li>\n</ol>\n<p>From now on, you will need to authenticate when accessing the app.</p>\n<p><img src=\"http://localhost/img/lastlogin.png\" alt=\"alt text\"></p>\n<p>We leverage <a href=\"https://lastlogin.io/\">lastlogin.io</a> to provide a simple and secure authentication mechanism. I might host my own instance of lastlogin in the future, but for now, I'm choosed to rely on the public instance.</p>\n<p>Alternatively, you can provide a token in the <code>Authorization</code> header.</p>\n<pre><code class=\"language-sh\">curl https://example-app.localhost --header &quot;Authorization: Bearer &lt;token&gt;&quot;\n</code></pre>\n<p>Or alternatively:</p>\n<pre><code class=\"language-sh\">curl https://&lt;token&gt;@example-app.localhost\n</code></pre>\n<p>To get a smallweb token, you can use the <code>smallweb token create</code> command.</p>\n<pre><code class=\"language-sh\">$ smallweb token create --description &quot;My secret token&quot;\nPj0e8hlwTolo7IoPo6ksA\n</code></pre>\n<h2 id=\"built-in-admin-apps\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.13/#built-in-admin-apps\" class=\"header-anchor\">Built-in Admin Apps</a></h2>\n<p>This new authentication mechanism enabled me to distribute admin services as part of smallweb. In this release, there are two admin apps available:</p>\n<ul>\n<li><code>webdav.&lt;your-domain&gt;</code>: A WebDAV server to manage your files</li>\n<li><code>cli.&lt;your-domain&gt;</code>: Allowing you to access the cli from your browser</li>\n</ul>\n<p>But i'm considering adding more in the future (feel free to suggest some!).</p>\n<h3 id=\"cli-service\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.13/#cli-service\" class=\"header-anchor\">cli service</a></h3>\n<p>You can now access the cli from your browser! This is a great way to manage a remote smallweb instance without having to ssh into it.</p>\n<p>If you go to <code>cli.&lt;your-domain&gt;</code>, you will be prompted to authenticate, then be able to run any command you want.</p>\n<p><img src=\"http://localhost/img/cli_demo.png\" alt=\"Smallweb CLI demo\"></p>\n<p>The cli is protected behind the same authentication mechanism as the rest of the apps.</p>\n<p><code>smallweb ls --json</code> -&gt; <code>curl -X POST 'https://cli.&lt;your-domain&gt;/ls?json' --header &quot;Authorization: Bearer my-secret-token&quot;</code></p>\n<p>In a future release, the cli service might include a terminal emulator using xterm.js.</p>\n<h3 id=\"webdav-service\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.13/#webdav-service\" class=\"header-anchor\">webdav service</a></h3>\n<p>I've been rediscovering the power of WebDAV recently, and I wanted to make it easy to pair it with smallweb. The built-in webdav servers allows you to manage/backup your smallweb folder using any webdav client.</p>\n<p>It means that smallweb can now be integrated with:</p>\n<ul>\n<li>All major operating systems (Windows, MacOS, Linux)</li>\n<li>Web based file managers (ex: <a href=\"https://www.filestash.app/\">https://www.filestash.app/</a>)</li>\n</ul>\n<p>To authenticate, you can either:</p>\n<ul>\n<li>Use bearer token authentication</li>\n<li>Use basic authentication, and provide the token as the <strong>username</strong></li>\n</ul>\n<p>Currently the WebDAV server does not comes with any UI, as I was not able to find a webdav client both easily embeddable and good-looking. If you have any suggestion, feel free to reach out!</p>\n<p>Having a webdav server also allows you to easily backup your smallweb apps using a tool like <a href=\"https://rclone.org/\"><code>rclone</code></a>.</p>\n<p><img src=\"http://localhost/img/webdav_demo.png\" alt=\"Smallweb WebDAV demo\"></p>\n<h2 id=\"cli-entrypoints\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.13/#cli-entrypoints\" class=\"header-anchor\">CLI entrypoints</a></h2>\n<p>Smallweb apps are required to export an object, as their default export, that contain's a <code>fetch</code> method to handle incoming requests.</p>\n<pre><code class=\"language-ts\">// ~/smallweb/example-app/main.ts\nexport default {\n    fetch: async (request: Request) =&gt; {\n        return new Response('Hello, World!');\n    }\n}\n</code></pre>\n<p>From now on, you can also register a <code>run</code> method to handle cli commands.</p>\n<pre><code class=\"language-ts\">// ~/smallweb/example-app/main.ts\nexport default {\n    fetch: async (request: Request) =&gt; {\n        return new Response('Hello, World!');\n    },\n    run: async (args: string[]) =&gt; {\n        console.log(`Hello, ${args[0]}!`);\n    }\n}\n</code></pre>\n<p>Once you have registered a <code>run</code> method, you can run it with the <code>smallweb run</code> command.</p>\n<pre><code class=\"language-console\">$ smallweb run example-app pomdtr\nHello, pomdtr!\n</code></pre>\n<p>Smallweb commands run with the same permissions as the app itself. You can access stdin/stdout/stderr, not spawn subprocesses.</p>\n<p>You can also access the newly created cli from the internal <code>cli.&lt;your-domain&gt;</code> service, either from your browser or using curl.</p>\n<pre><code class=\"language-sh\">curl -X POST https://cli.&lt;your-domain&gt;/run/example-app/pomdtr -H &quot;Authorization: Bearer my-secret-token&quot;\n</code></pre>\n<p>These cli entrypoints are also leveraged for cron tasks (which schema has been updated in this release).</p>\n<pre><code class=\"language-json\">// ~/smallweb/example-app/smallweb.json\n{\n    &quot;crons&quot;: [\n        {\n            &quot;name&quot;: &quot;say-hello-to-pomdtr&quot;,\n            &quot;description&quot;: &quot;Say hello to pomdtr every day&quot;,\n            &quot;schedule&quot;: &quot;0 0 * * *&quot;,\n            &quot;args&quot;: [&quot;pomdtr&quot;]\n        }\n    ]\n}\n</code></pre>\n<h2 id=\"updated-permissions\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.13/#updated-permissions\" class=\"header-anchor\">Updated permissions</a></h2>\n<p>You used to be able to customize the permissions of a smallweb app using the <code>permissions</code> field in the app config. There was a big issue with this approach: if an app had write access to the filesystem, it could edit it's own permissions, and escalate its privileges.</p>\n<p>Since I envision smallweb as a platform where user can run remote or AI generated code, I wanted to make sure that the permissions of an app are as restricted as possible.</p>\n<p>In this release, app permissions are now longer customizable. Instead, each smallweb app is allowed to:</p>\n<ul>\n<li>read and write in its own directory</li>\n<li>access the network using the fetch API</li>\n<li>access the env variable defined either in the global config or in the <code>.env</code> file</li>\n</ul>\n<p>If you want to give you app additional permissions, you can provide it with a token has an environment variable.</p>\n<pre><code class=\"language-sh\"># ~/smallweb/example-app.env\nSMALLWEB_TOKEN=my-secret-token\n</code></pre>\n<p>Then, you'll be able to access the cli from your app:</p>\n<pre><code class=\"language-ts\">const token = Deno.env.get(&quot;SMALLWEB_TOKEN&quot;);\n\nconst resp = await fetch(&quot;https://cli.&lt;your-domain&gt;/ls?json&quot;, {\n    headers: {\n        method: &quot;POST&quot;,\n        Authorization: `Bearer ${token}`,\n    }\n});\n\nconst apps = await resp.json();\n</code></pre>\n<p>Or build your own smallweb editor using a <a href=\"https://www.npmjs.com/package/webdav\">WebDAV client</a>!</p>\n<h2 id=\"smallweb-edit-command\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.13/#smallweb-edit-command\" class=\"header-anchor\"><code>smallweb edit</code> command</a></h2>\n<p>Use the <code>smallweb edit [app]</code> command to open an app in your default editor.</p>\n<p>Of course, it integrates with the <code>cli.&lt;your-domain&gt;</code> service, allowing you to edit your apps from your browser.</p>\n<h2 id=\"smallweb-types-command\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.13/#smallweb-types-command\" class=\"header-anchor\"><code>smallweb types</code> command</a></h2>\n<p>With the addition of the <code>run</code> method, it can become a bit cumbersome to check that your default export is compatible with the expected smallweb schema.</p>\n<p>I added a new <code>smallweb types</code> command to help you generate types hint.</p>\n<p>To add the smallweb types to your project, run:</p>\n<pre><code class=\"language-sh\">smallweb types &gt; smallweb.d.ts\n</code></pre>\n<p>You can then reference them in your project:</p>\n<pre><code class=\"language-ts\">export default {\n    fetch: async (request) =&gt; {\n        return new Response('Hello, World!');\n    },\n    run: async (args) =&gt; {\n        console.log(`Hello, ${args[0]}!`);\n    }\n} satisfies Smallweb.App;\n</code></pre>\n<h2 id=\"simplified-global-configuration\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.13/#simplified-global-configuration\" class=\"header-anchor\">Simplified Global Configuration</a></h2>\n<p>The global configuration now has the following schema:</p>\n<pre><code class=\"language-json\">// ~/.config/smallweb/config.json\n{\n    &quot;host&quot;: &quot;127.0.0.1&quot;,\n    &quot;port&quot;: 8080,\n    &quot;domain&quot;: &quot;smallweb.run&quot;,\n    &quot;dir&quot;: &quot;~/smallweb&quot;,\n    &quot;tokens&quot;: [\n        &quot;my-secret-token&quot;\n    ],\n}\n</code></pre>\n<p>All of these fields can also be provided using environment variables (ex: <code>host</code> can be provided using the <code>SMALLWEB_HOST</code> environment variable).</p>\n<p>As you can see, the complex domain rooting from previous versions has been dropped. A smallweb instance maps a single wildcard domain to a single directory. If you want to manage multiple domains, feel free to run multiple instances of smallweb!</p>\n<p>ex: I host two instances of smallweb on my hetzner VM (<code>smallweb.run</code> and <code>pomdtr.me</code>). To do so, I created two users (<code>smallweb.run</code> and <code>pomdtr.me</code>), and run smallweb as a service for each of them.</p>\n<p>Of course, you can still attach a custom domain to a specific app by adding a <code>CNAME</code> file in the app directory, containing the domain you want to attach.</p>\n<h2 id=\"updated-app-config\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.13/#updated-app-config\" class=\"header-anchor\">Updated app config</a></h2>\n<p>The schema of the smallweb config was updated:</p>\n<pre><code class=\"language-json\">{\n    &quot;private&quot;: true,\n    &quot;entrypoint&quot;: &quot;main.ts&quot;,\n    &quot;root&quot;: &quot;public&quot;,\n    &quot;crons&quot;: []\n}\n</code></pre>\n<p>We already detailed above:</p>\n<ul>\n<li>The addition of the <code>private</code> field</li>\n<li>The removal of the <code>permissions</code> field</li>\n<li>The update of the <code>crons</code> field</li>\n</ul>\n<p>In addition to this:</p>\n<ul>\n<li>the <code>serve</code> field was replaced by the <code>entrypoint</code> field. You can use it to specify which file exports the app object. If you don't provide it, smallweb will default to <code>main.[js,ts,jsx,tsx]</code>.</li>\n<li>the <code>root</code> field allows you to specify the root directory of the app. The <code>entrypoint</code> file will be resolved relative to this directory.</li>\n</ul>\n<p>Smallweb no longer serve static files by default. If you want to serve static files, you can use the following main.ts:</p>\n<pre><code class=\"language-ts\">// ~/smallweb/example-app/main.ts\nimport { serveDir } from &quot;jsr:@std/http/file-server&quot;;\n\nexport default {\n  fetch: (req: Request) =&gt; serveDir(req, {\n    // The root directory of the app\n    fsRoot: &quot;./static&quot;,\n  }),\n}\n</code></pre>\n<p>Or even simpler, add the following <code>smallweb.json</code> file:</p>\n<pre><code class=\"language-json\">{\n    &quot;entrypoint&quot;: &quot;jsr:@smallweb/file-server&quot;,\n    &quot;root&quot;: &quot;static&quot; // or omit it to serve the whole app directory\n}\n</code></pre>\n","date_published":"Sun, 01 Sep 2024 00:00:00 GMT"},{"id":"http://localhost/posts/v0.12/","url":"http://localhost/posts/v0.12/","title":"Smallweb 0.12 - Publish and install flow for smallweb apps","content_html":"<p>Smallweb 0.12 is out! And it's the first release since 0.8 where I do not feel the need to fondamentally change the routing system 😅.</p>\n<p>But this is still a big release! And it even contains a few breaking changes (don't worry, they are easy to fix).</p>\n<h2 id=\"smallweb-install%3A-a-new-convention-to-install-and-publish-smallweb-apps\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.12/#smallweb-install%3A-a-new-convention-to-install-and-publish-smallweb-apps\" class=\"header-anchor\"><code>smallweb install</code>: A new convention to install and publish smallweb apps</a></h2>\n<p>Smallweb now includes a new <code>smallweb install</code> command to install smallweb apps from the web.</p>\n<p>Smallweb apps work on top of github repositories. When you run</p>\n<pre><code class=\"language-sh\">smallweb install pomdtr/example-app ~/localhost/smallweb-app\n</code></pre>\n<p>smallweb will clone the <code>pomdtr/example-app</code> repository in the <code>~/localhost/smallweb-app</code> folder.</p>\n<!-- more -->\n<p>If the repository contains a <code>smallweb</code> branch, smallweb will checkout this branch. Otherwise, it will checkout the <code>main</code> branch.</p>\n<p>This convention is really similar to how github pages work, and you can even repurposes github pages actions to build your smallweb app (see <a href=\"https://github.com/pomdtr/smallweb-blog/blob/main/.github/workflows/deploy.yml#L24\">how this blog is built</a> for an example).</p>\n<p>Once an app is installed, you can use the <code>git</code> cli to manage them. For example, you can run <code>git pull</code> to update the app to the latest version, or <code>git checkout &lt;hash&gt;</code> to rollback to a previous version. Take a look to the <a href=\"https://github.com/pomdtr/smallweb-puller\">pomdtr/smallweb-puller repository</a> for a simple way to trigger an app update from the ouside.</p>\n<p>If you create a smallweb app, make sure to add the <code>smallweb-app</code> topic to your repository.</p>\n<h2 id=\"smallweb-init-now-support-custom-templates\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.12/#smallweb-init-now-support-custom-templates\" class=\"header-anchor\"><code>smallweb init</code> now support custom templates</a></h2>\n<p>The <code>smallweb init</code> was reworked to allow users to define custom templates from github. Smallweb templates are just github repositories with a <code>smallweb-template</code> topic.</p>\n<p>The new command usage is:</p>\n<pre><code class=\"language-ts\">smallweb init [dir] [--template &lt;repo&gt;]\n</code></pre>\n<p>When you run <code>smallweb init example --template pomdtr/smallweb-template-astro</code>, smallweb will download the content of the <code>pomdtr/smallweb-template-astro</code> repository in the <code>example</code> folder (without creating a <code>.git</code> folder).</p>\n<h2 id=\"crons-jobs-are-now-defined-as-http-requests\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.12/#crons-jobs-are-now-defined-as-http-requests\" class=\"header-anchor\">Crons jobs are now defined as HTTP requests</a></h2>\n<p>Crons uses to be defined as shell commands:</p>\n<pre><code class=\"language-json\">{\n    &quot;crons&quot;: [\n        {\n            &quot;schedule&quot;: &quot;0 0 * * *&quot;,\n            &quot;command&quot;: &quot;deno&quot;,\n            &quot;args&quot;: [&quot;run&quot;, &quot;--allow-net&quot;, &quot;https://example.com/cron.ts&quot;]\n        }\n    ]\n}\n</code></pre>\n<p>This had a few limitations:</p>\n<ul>\n<li>crons did not respect the permissions of the app</li>\n<li>getting access to the same Deno KV instance was tricky in some cases</li>\n</ul>\n<p>For these reasons (and in preparation for the upcoming hosted version of smallweb), crons are now defined as HTTP requests:</p>\n<pre><code class=\"language-json\">// smallweb.json\n{\n    &quot;crons&quot;: [\n        {\n            &quot;schedule&quot;: &quot;0 0 * * *&quot;,\n            &quot;path&quot;: &quot;/refresh&quot;,\n        }\n    ]\n}\n</code></pre>\n<p>This is the exact same API as <a href=\"https://vercel.com/guides/how-to-setup-cron-jobs-on-vercel\">Vercel's cron</a>, so you can refer to their documentation for some examples of how to use it.</p>\n<p>This also remove the need for the <code>smallweb cron trigger</code> command (as you can just go to <code>https://&lt;app&gt;/refresh</code> to trigger the cron).</p>\n<p><code>smallweb cron list</code> was moved to <code>smallweb crons</code>.</p>\n<h2 id=\"smallweb-open-has-new-flags\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.12/#smallweb-open-has-new-flags\" class=\"header-anchor\"><code>smallweb open</code> has new flags</a></h2>\n<p>Smallweb open now supports opening both using the app name or dir:</p>\n<pre><code class=\"language-sh\"># open the react.localhost app\nsmallweb open --app react.localhost\n# open the located at ~/localhost/react\nsmallweb open --dir ~/localhost/react\n# open the current directory\nsmallweb open\n</code></pre>\n<h2 id=\"deno-kv-is-now-scoped-to-the-hostname\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.12/#deno-kv-is-now-scoped-to-the-hostname\" class=\"header-anchor\">Deno KV is now scoped to the hostname</a></h2>\n<p>If you map multiple domains to the same dir:</p>\n<pre><code class=\"language-json\">{\n    &quot;*-kv.smallweb.run&quot;: &quot;~/kv&quot;\n}\n</code></pre>\n<p>And uses the default KV instance:</p>\n<pre><code class=\"language-ts\">// ~/kv/main.ts\n\nconst kv = await Deno.openKv()\n</code></pre>\n<p><code>example-kv.smallweb.run</code> and <code>another-kv.smallweb.run</code> will not share the same KV instance. This behavior will allow some cool new usecases (ex: preview deployments with distinct KV instances).</p>\n<p>If you want to share a db between multiple hostnames, you can always specify a kv path in your code:</p>\n<pre><code class=\"language-ts\">const kv = await Deno.openKv({ path: &quot;./kv.db&quot; })\n</code></pre>\n<h2 id=\"what's-next%3F\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.12/#what's-next%3F\" class=\"header-anchor\">What's next?</a></h2>\n<p>I really feel smallweb is in a good state right now, and I want to grow its community. I just bought a new mic and plan to record some videos to showcase smallweb features on YouTube and Twitter.</p>\n<p>Improved logs are still a priority. I want to move logs to their own file instead of using stderr/stdout, and allow you to filter them by app/time by storing them as JSON lines.</p>\n<p>Now that we have an efficient way to distribute and install apps, I want to port more apps to smallweb. I hope you'll help me with this one!</p>\n<p>And finally, I plan to resume the work on smallweb sister project, smallbrowser.</p>\n","date_published":"Tue, 23 Jul 2024 00:00:00 GMT"},{"id":"http://localhost/posts/why-smallweb/","url":"http://localhost/posts/why-smallweb/","title":"Why smallweb?","content_html":"<p>Think about the last time you worked on a local project. You probably had to:</p>\n<ol>\n<li>Open your project in your favorite editor</li>\n<li>Start a development server</li>\n<li>Open your browser and navigate to <code>http://localhost:3000</code> or any other port</li>\n</ol>\n<p>There are a few things that are not great about this workflow:</p>\n<ol>\n<li>You have to go through a few manual steps to start your project. Why can't it be running all the time?</li>\n<li>Multiple projects can't run on the same port. You have to remember which project is running on which port.</li>\n<li>Using <code>http://</code> is very limiting. For example, you can't install a PWA if it's not served over HTTPS.</li>\n</ol>\n<!-- more -->\n<h2 id=\"why-can't-it-be-running-all-the-time%3F\" tabindex=\"-1\"><a href=\"http://localhost/posts/why-smallweb/#why-can't-it-be-running-all-the-time%3F\" class=\"header-anchor\">Why can't it be running all the time?</a></h2>\n<p>An elegant way to address some of these issues is to use a reverse proxy like caddy, and self-signed certificates. Your proxy configuration would look something like this:</p>\n<pre><code class=\"language-txt\">website.localhost {\n  tls internal {\n    on_demand\n  }\n\n  reverse_proxy localhost:3000\n}\n</code></pre>\n<p>By setting up a reverse proxy, you can access your project using <code>https://website.localhost</code> instead of <code>http://localhost:3000</code>. This is a great improvement, but it's still not perfect: you still have to manually start your project.</p>\n<p>At this point you might be tempted to write a service that starts your project when you boot your computer. But this becomes cumbersome really fast, and it will end up consuming a lot of resources (each project on computer would be running all the time).</p>\n<h2 id=\"taking-inspiration-from-serverless\" tabindex=\"-1\"><a href=\"http://localhost/posts/why-smallweb/#taking-inspiration-from-serverless\" class=\"header-anchor\">Taking inspiration from Serverless</a></h2>\n<p>Platforms like <a href=\"https://vercel.com/\">Vercel</a>, <a href=\"https://deno.com/deploy\">Deno Deploy</a> or <a href=\"https://val.town/\">Val Town</a> allow each user to host a unlimited amount of websites for free. How can they afford to do that? They don't run your code all the time. Instead, they start a new process when a request comes in, and they shut it down when it's done.</p>\n<p>This sounds like a great idea, could we do the same thing, but self-hosted? This is the idea behind smallweb.</p>\n<p>Instead of having all project running at all time, we will only have a single smallweb evaluation server running on port 7777.</p>\n<pre><code class=\"language-txt\">*.localhost {\n  tls internal {\n    on_demand\n  }\n\n  reverse_proxy localhost:7777\n}\n</code></pre>\n<p>When a new request comes in, smallweb will map the hostname to a folder in your filesystem:</p>\n<pre><code class=\"language-txt\">website.localhost -&gt; ~/localhost/website\n</code></pre>\n<p>Smallweb will then start a new process, and look for a <code>main.ts</code> file in the folder. If it finds one, it will evaluate it and proxy the response back.</p>\n<pre><code class=\"language-ts\">// ~/localhost/website/main.ts\n\nexport default {\n    fetch: (req: Request) =&gt; new Response(&quot;Hello, World!&quot;)\n}\n</code></pre>\n<pre><code class=\"language-console\">$ curl https://website.localhost\nHello, World!\n</code></pre>\n<h2 id=\"managing-servers-with-unix-commands\" tabindex=\"-1\"><a href=\"http://localhost/posts/why-smallweb/#managing-servers-with-unix-commands\" class=\"header-anchor\">Managing servers with unix commands</a></h2>\n<p>Since hostnames are mapped to folders in your filesystem, you can use unix commands to manage your servers.</p>\n<p>For example, you can clone a website by copying the folder:</p>\n<pre><code class=\"language-sh\">$ cp -r ~/localhost/website ~/localhost/website-clone\n$ curl https://website-clone.localhost\nHello, World!\n</code></pre>\n<p>If you want to rename it, use the <code>mv</code> command. To delete it, use the <code>rm</code> command.</p>\n<h2 id=\"running-smallweb-on-the-server\" tabindex=\"-1\"><a href=\"http://localhost/posts/why-smallweb/#running-smallweb-on-the-server\" class=\"header-anchor\">Running smallweb on the Server</a></h2>\n<p>I've focused on the local dev experience so far, but there is nothing stopping you from running smallweb on a server.</p>\n<p>In fact, this is how I host this blog, and every other <code>smallweb.run</code> websites from a 5$ Hetzner VPS.</p>\n<p>With smallweb running on my server, I can host as many websites as I want, as the amount of resouces consumed depends on the amount of traffic I get, not the amount of websites I have.</p>\n<p>As much my websites don't have any visitors, this is probably the right tradeoff to make 😅.</p>\n","date_published":"Tue, 23 Jul 2024 00:00:00 GMT"},{"id":"http://localhost/posts/v0.11/","url":"http://localhost/posts/v0.11/","title":"Smallweb 0.11 - Global config and new routing","content_html":"<h2 id=\"a-new-(optional)-global-config\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.11/#a-new-(optional)-global-config\" class=\"header-anchor\">A new (optional) global config</a></h2>\n<p>You can now configure the smallweb host, port, and other global settings in a <code>~/.config/smallweb/config.json</code> file.</p>\n<p>Here is the implicit default configuration if the file does not exist:</p>\n<pre><code class=\"language-json\">{\n    &quot;host&quot;: &quot;127.0.0.1&quot;,\n    &quot;port&quot;: 7777,\n    &quot;domains&quot;: {\n        &quot;*.localhost&quot;: &quot;~/localhost/*&quot;\n    },\n    &quot;env&quot;: {\n        &quot;DENO_TLS_CA_STORE&quot;: &quot;system&quot;\n    }\n}\n</code></pre>\n<!-- more -->\n<p>Smallweb also supports the following environment variables:</p>\n<ul>\n<li><code>SMALLWEB_HOST</code></li>\n<li><code>SMALLWEB_PORT</code></li>\n</ul>\n<h2 id=\"config-based-routing\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.11/#config-based-routing\" class=\"header-anchor\">Config Based Routing</a></h2>\n<p>You might have noticed the new <code>domains</code> key in the global config.</p>\n<p>It's part of a new routing system that allows you to map domains to folders in your filesystem.</p>\n<p>For example, you can map:</p>\n<ul>\n<li><code>pomdtr.me</code> to <code>~/pomdtr.me</code>: All requests to <code>pomdtr.me</code> will be served from the <code>~/pomdtr.me</code> folder.</li>\n<li><code>*.smallweb.run</code> to <code>~/smallweb.run/*</code>: All requests to <code>&lt;app&gt;.smallweb.run</code> will be served from the <code>~/smallweb.run/&lt;app&gt;</code> folder.</li>\n<li><code>*.example.me</code> to <code>~/example.com</code>: All requests to <code>*.example.me</code> will be served from the <code>~/example.com</code> folder.</li>\n</ul>\n<p>The config is live-reloaded, so you can change it on the fly.</p>\n<p>I hope this new system will allows advanced users to handle more advanced routing scenarios, while keeping the simplicity of the original system.</p>\n<p>This change also means that the notion of a &quot;smallweb root&quot; is now deprecated. You can put your smallweb apps anywhere in your filesystem.</p>\n<h2 id=\"smallweb-open\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.11/#smallweb-open\" class=\"header-anchor\"><code>smallweb open</code></a></h2>\n<p>Smallweb open now works on top of directories.</p>\n<p>To open the app from the current directory in your browser, you can run:</p>\n<pre><code class=\"language-sh\">smallweb open .\n</code></pre>\n<p>Or do something like this if you have a blog stored at <code>~/localhost/blog</code>:</p>\n<pre><code class=\"language-sh\">smallweb open ~/localhost/blog\n</code></pre>\n<h2 id=\"smallweb-create--%3E-smallweb-init\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.11/#smallweb-create--%3E-smallweb-init\" class=\"header-anchor\"><code>smallweb create</code> -&gt; <code>smallweb init</code></a></h2>\n<p><code>smallweb create</code> was replaced by <code>smallweb init</code>.</p>\n<p>If you want <code>smallweb init</code>, you'll get an interactive prompt to create a new project.</p>\n<p>You can also skip the prompts by passing the appropriate args and flags.</p>\n<pre><code class=\"language-sh\">smallweb init ~/localhost/hono-app --template hono\n</code></pre>\n","date_published":"Wed, 17 Jul 2024 00:00:00 GMT"},{"id":"http://localhost/posts/v0.10/","url":"http://localhost/posts/v0.10/","title":"Smallweb 0.10 - Cron jobs are here!","content_html":"<h2 id=\"smallweb-now-supports-cron-jobs\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.10/#smallweb-now-supports-cron-jobs\" class=\"header-anchor\">Smallweb now supports cron jobs</a></h2>\n<p>Cron jobs were one of the key features missing from smallweb.\nYou can now defines them from the <code>smallweb.json[c]</code> file.</p>\n<pre><code class=\"language-json\">{\n  &quot;crons&quot;: [\n    {\n      &quot;name&quot;: &quot;my-cron-job&quot;,\n      &quot;schedule&quot;: &quot;0 0 * * *&quot;,\n      &quot;command&quot;: &quot;echo&quot;,\n      &quot;args&quot;: [&quot;hello world!&quot;]\n    }\n  ]\n}\n</code></pre>\n<!-- more -->\n<p>Cron jobs are defined by a name, a schedule, a command, and optional arguments.</p>\n<p>The minimum schedule is <code>* * * * *</code> which means every minute. <a href=\"https://crontab.guru/\">crontab.guru</a> is a great tool to help you define your schedule.</p>\n<p>Additionally, two new commands were added to manage cron jobs:</p>\n<ul>\n<li><code>smallweb cron list</code> to list all cron jobs</li>\n<li><code>smallweb cron trigger</code> to trigger a cron job manually</li>\n</ul>\n<p>Make sure to setup the completions for your shell to get the full experience.</p>\n<p>More information can be found in the <a href=\"https://docs.smallweb.run/guides/cron.html\">documentation</a>.</p>\n<h2 id=\"smallweb-create-is-now-interactive\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.10/#smallweb-create-is-now-interactive\" class=\"header-anchor\"><code>smallweb create</code> is now interactive</a></h2>\n<p>You can now just run <code>smallweb create</code> to initialize a new project.</p>\n<p>It will ask you a few questions and generate a new project for you.\nYou can skip the questions by passing the <code>--name</code> and <code>--template</code> flags.</p>\n<h2 id=\"what's-next%3F\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.10/#what's-next%3F\" class=\"header-anchor\">What's next?</a></h2>\n<p>I want to focus on improving the logs experience in the next release.</p>\n<p>Currently, all logs are grouped together, and there is no way to filter between:</p>\n<ul>\n<li>system logs (ex: http requests)</li>\n<li>application logs (ex: stdout/stderr)</li>\n</ul>\n<p>The user should also be able to filter logs by domain, or application.</p>\n<p>In order to achieve this, I'm thinking of emitting logs as json to stdout, and converting them to human readable format in the cli.</p>\n<p>I also plan to work on:</p>\n<ul>\n<li>a landing page for smallweb</li>\n<li>a demo video showcasing the features</li>\n</ul>\n","date_published":"Sat, 13 Jul 2024 00:00:00 GMT"},{"id":"http://localhost/posts/v0.9/","url":"http://localhost/posts/v0.9/","title":"Smallweb 0.9 - Improved Routing","content_html":"<h2 id=\"updated-routing\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.9/#updated-routing\" class=\"header-anchor\">Updated Routing</a></h2>\n<p>After a lot of feedback shared by community, the routing was rethinked from the\nground up. Thanks everyone for sharing your thoughts!</p>\n<p>Here is what your smallweb root folder (which defaults to <code>~/smallweb</code>) should\nnow look like:</p>\n<pre><code class=\"language-txt\">~/smallweb/\n├── localhost\n│   ├── example\n│   │   └── main.ts\n│   └── react\n│       └── main.ts\n├── pomdtr.me\n│   └── www\n│       └── main.ts\n└── smallweb.run\n    ├── www\n    │   └── main.ts\n    ├── assets\n    │   └── main.ts\n    └── readme\n        └── main.ts\n</code></pre>\n<!-- more -->\n<p>The first level of subfolder is the apex domain, and the second one is the\nsubdomain.</p>\n<ul>\n<li><code>https://assets.smallweb.run</code> will be routed to\n<code>~/smallweb/smallweb.run/assets/</code></li>\n<li><code>react.localhost</code> will be routed to <code>~/smallweb/localhost/react/</code></li>\n</ul>\n<p>Request targeting the apex domain will be automatically redirected to the <code>www</code>\nsubdomain.</p>\n<p>You can read more about the design process in the\n<a href=\"http://localhost/blog/routing-design.md\">dedicated blog post</a>.</p>\n<h2 id=\"smallweb-list\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.9/#smallweb-list\" class=\"header-anchor\">smallweb list</a></h2>\n<p>The smallweb dump command was renamed to <code>smallweb list</code>.</p>\n<p>Smallweb list supports both human and machine readable output (with a <code>--json</code>\nflag).</p>\n<p>You can filter by domain using the <code>--domain</code> flag.</p>\n<h2 id=\"smallweb-open\" tabindex=\"-1\"><a href=\"http://localhost/posts/v0.9/#smallweb-open\" class=\"header-anchor\">smallweb open</a></h2>\n<p>The <code>smallweb open</code> command can now open smallweb websites, even when your\ncurrent directory is not the root of a smallweb app.</p>\n<p>Just pass the app name to the command:</p>\n<pre><code class=\"language-sh\">smallweb open react.localhost\n</code></pre>\n<p>The command provides completions, make sure to set them properly. You can get\nshell specific instructions using the <code>smallweb help completion</code> command.</p>\n","date_published":"Fri, 12 Jul 2024 00:00:00 GMT"},{"id":"http://localhost/posts/routing-design/","url":"http://localhost/posts/routing-design/","title":"Rethinking Smallweb Routing","content_html":"<p>Smallweb <code>v0.8.0</code> was released yesterday, and it included the first smallweb\nbreaking change.</p>\n<blockquote>\n<p>The <code>~/www</code> convention was dropped, the defaut folder is now <code>~/smallweb</code></p>\n<p>In addition to this change, the folder should now be named after the hostname:</p>\n<ul>\n<li>example.smallweb.run =&gt; ~/smallweb/example.smallweb.run/</li>\n<li>pomdtr.me =&gt; ~/smallweb/pomdtr.me/</li>\n<li>example.localhost =&gt; ~/smallweb/example.localhost/</li>\n</ul>\n</blockquote>\n<p>This change was not really well received:</p>\n<blockquote>\n<p>I'm not a fan of the new hostname folder convention. It feels noisy.</p>\n<p>I'm also a bit frustrated by this change, and this is my main gripe with it\ntoo. And this &quot;ugliness&quot; is (for me) exacerbated by the fact that there's\ngoing to be a lot of repetition if all my smallweb apps are <code>&lt;app&gt;.localhost</code>.\nI would prefer a convention like <code>~/smallweb/localhost/example</code> mapping to\n<code>example.localhost</code></p>\n</blockquote>\n<p>In this post, I'll try to address:</p>\n<ul>\n<li>the drawbacks of the previous convention</li>\n<li>the options I've considered</li>\n</ul>\n<!-- more -->\n<h2 id=\"why-a-change-was-needed\" tabindex=\"-1\"><a href=\"http://localhost/posts/routing-design/#why-a-change-was-needed\" class=\"header-anchor\">Why a change was needed</a></h2>\n<p>The smallweb routing system was originally designed for a single usecase:\nhosting a unlimited amount of websites locally, using <code>*.localhost</code> domains.</p>\n<p>The convention was to:</p>\n<ul>\n<li>store all of your website in the smallweb root (<code>~/www</code> by default)</li>\n<li>use the folder name has the subdomain</li>\n</ul>\n<p>So <code>~/www/example/</code> would be mapped to <code>https://example.localhost</code>.</p>\n<p>As the project expanded, new usecases emerged for smallweb: hosting smallweb on\na raspberrypi, or even on a VPS from hetzner/digital ocean...</p>\n<p>And the intitial design hold quite well with these usecases. You would just\nassign a domain to your device (ex: <code>*.pomdtr.me</code>), and <code>~/www/example/</code> would\nmap to <code>https://example.pomdtr.me</code>.</p>\n<p>But what if I wanted to assign multiple domains to a single machine ? If I route\nboth <code>*.pomdtr.me</code> and <code>*.smallweb.run</code> to my machine, <code>~/www/example</code> will\nmatch both <code>https://example.pomdtr.me</code> and <code>https://example.smallweb.run</code>. This\nis probably not what the user want in most cases.</p>\n<h2 id=\"options-i've-considered\" tabindex=\"-1\"><a href=\"http://localhost/posts/routing-design/#options-i've-considered\" class=\"header-anchor\">Options I've considered</a></h2>\n<p>Let's say we want to manage the following websites using smallweb.</p>\n<ul>\n<li><code>https://smallweb.run</code></li>\n<li><code>https://readme.smallweb.run</code></li>\n<li><code>https://assets.smallweb.run</code></li>\n<li><code>https://pomdtr.me</code></li>\n<li><code>https://example.localhost</code></li>\n<li><code>https://react.localhost</code></li>\n</ul>\n<p>We'll assume that all of these websites are defined in a single <code>main.ts</code>.</p>\n<h3 id=\"option-1%3A-not-using-the-folder-name\" tabindex=\"-1\"><a href=\"http://localhost/posts/routing-design/#option-1%3A-not-using-the-folder-name\" class=\"header-anchor\">Option 1: Not using the folder name</a></h3>\n<p>We could just allow arbitrary folder names, and just use a CNAME at the root of\nthe app, specifying the domain name.</p>\n<pre><code class=\"language-txt\">assets.smallweb.run\n</code></pre>\n<p>It sounds like a fine solution, but it means that every smallweb website would\nneed to include it. I really want single-file websites to be able to exist, and\nI feel like file based routing is a core feature of smallweb, so I did not go\nwith this option.</p>\n<h3 id=\"option-2%3A-using-a-nested-structure\" tabindex=\"-1\"><a href=\"http://localhost/posts/routing-design/#option-2%3A-using-a-nested-structure\" class=\"header-anchor\">Option 2: Using a Nested structure</a></h3>\n<pre><code class=\"language-txt\">/\n├── localhost\n│   ├── example\n│   │   └── main.ts\n│   └── react\n│       └── main.ts\n├── me\n│   └── pomdtr\n│       └── main.ts\n└── run\n    └── smallweb\n        ├── main.ts\n        ├── assets\n        │   └── main.ts\n        └── readme\n            └── main.ts\n</code></pre>\n<p>Of course, this is not acceptable. If we look at the <code>/run/smallweb</code> folder, we\ncan see that it contains both:</p>\n<ul>\n<li>the code of the <code>https://smallweb.run</code> homepage at his root.</li>\n<li>the code of <code>readme</code> and <code>assets</code> subdomains</li>\n</ul>\n<p>If we used a git repository to manage each of those websites, this would quickly\nbecome a mess.</p>\n<p>To counter this, we can add a convention: if the request target a root domain,\nit will be automatically redirected to the <code>www</code> domain.</p>\n<pre><code class=\"language-txt\">/\n├── localhost\n│   ├── example\n│   │   └── main.ts\n│   └── react\n│       └── main.ts\n├── me\n│   └── pomdtr\n│       └── www\n│           └── main.ts\n└── run\n    └── smallweb\n        ├── assets\n        │   └── main.ts\n        ├── readme\n        │   └── main.ts\n        └── www\n            └── main.ts\n</code></pre>\n<p>This looks better! However, it still feels like we have some uncessary nesting.</p>\n<p>For example, the <code>/run</code> folder only has one subfolder: <code>/run/smallweb</code>. Folders\nare supposed to group related websites, but websites sharing the same TLD\nprobably have nothing in common.</p>\n<p>Even worse, <code>pomdtr.me</code> requires 3 (!!!) level of nesting: <code>/me/pomdtr/www</code>.</p>\n<h3 id=\"option-3%3A-2-level-structure\" tabindex=\"-1\"><a href=\"http://localhost/posts/routing-design/#option-3%3A-2-level-structure\" class=\"header-anchor\">Option 3: 2-level structure</a></h3>\n<p>Instead of splitting on <code>.</code>, we'll use the apex domain as the first level of\nsubfolder, and the subdomain as the second one.</p>\n<p>If a request target the apex domain, will automatically redirect it to the <code>www</code>\nsubdomain.</p>\n<pre><code class=\"language-txt\">/\n├── localhost\n│   ├── example\n│   │   └── main.ts\n│   └── react\n│       └── main.ts\n├── pomdtr.me\n│   └── www\n│       └── main.ts\n└── smallweb.run\n    ├── www\n    │   └── main.ts\n    ├── assets\n    │   └── main.ts\n    └── readme\n        └── main.ts\n</code></pre>\n<p>We still have some uncessary nesting (<code>pomdtr/www</code>), but we get meaningful\ngroups in exchange.</p>\n<p>Here the folder structure kind of reflect the process of updating DNS records in\ncloudflare.</p>\n<h3 id=\"option-4%3A-flat-structure\" tabindex=\"-1\"><a href=\"http://localhost/posts/routing-design/#option-4%3A-flat-structure\" class=\"header-anchor\">Option 4: Flat structure</a></h3>\n<p>Let's drop the nesting, and use the domain name as the folder name:</p>\n<pre><code class=\"language-txt\">/\n├── assets.smallweb.run\n│   └── main.ts\n├── example.localhost\n│   └── main.ts\n├── pomdtr.me\n│   └── main.ts\n├── react.localhost\n│   └── main.ts\n├── readme.smallweb.run\n│   └── main.ts\n└── smallweb.run\n    └── main.ts\n</code></pre>\n<p>Using the domain name as the folder looks kind of ugly, but it avoid the nested\nfolders problem entirely. One big advantage of this architecture is that you can\ncreate a new website from a git repository by just doing:</p>\n<pre><code class=\"language-sh\">git clone &lt;repo-url&gt; &lt;hostname&gt;\n</code></pre>\n<p>My main gripe with it (outside of the noisy folder names), is that related\nwebsites appears in different places in the file tree (ex: <code>react.localhost</code> and\n<code>example.localhost</code> are not next to each others).</p>\n<p>We can fix it by reversing the folder names:</p>\n<pre><code class=\"language-txt\">/\n├── localhost.example\n│   └── main.ts\n├── localhost.react\n│   └── main.ts\n├── me.pomdtr\n│   └── main.ts\n├── run.smallweb\n│   └── main.ts\n├── run.smallweb.assets\n│   └── main.ts\n└── run.smallweb.readme\n    └── main.ts\n</code></pre>\n<p>I quite like this compromise, but I'm not sure it would address the noisyness\nreported by the community.</p>\n<h2 id=\"what-do-you-think-%3F\" tabindex=\"-1\"><a href=\"http://localhost/posts/routing-design/#what-do-you-think-%3F\" class=\"header-anchor\">What do you think ?</a></h2>\n<p>Here are the two options I'm considering as default:</p>\n<ol>\n<li>2-level structure</li>\n<li>Reversed Flat structure</li>\n</ol>\n<p>Writing this article, I've come to gain more appreciation of the two\nlevel-structure, as it mirrors the process of setting up DNS record in your\ndomain registrar. However, the reversed flat structure is far more\nstraightforward, which is a plus in my book.</p>\n<p>I wonder if we should support both options (remix-style).</p>\n<p>I would love to hear your thoughts on all of this. Make sure to join the\n<a href=\"https://discord.gg/36jsj3rS\">discord channel</a> if you want your voice to be\nheard.</p>\n","date_published":"Thu, 11 Jul 2024 00:00:00 GMT"}]}