<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" version="2.0">
  <channel>
    <title>Smallweb Blog</title>
    <link>http://localhost/</link>
    <atom:link href="http://localhost/feed.xml" rel="self" type="application/rss+xml"/>
    <description>The latest new from Smallweb</description>
    <lastBuildDate>Tue, 01 Oct 2024 11:13:53 GMT</lastBuildDate>
    <language>en</language>
    <generator>Lume v2.2.2</generator>
    <item>
      <title>Smallweb 0.14 - REST Api, Static Sites and more...</title>
      <link>http://localhost/posts/v0.14/</link>
      <guid isPermaLink="false">http://localhost/posts/v0.14/</guid>
      <content:encoded>
        <![CDATA[<p>Smallweb <code>0.14</code> is the first release approaching the vision I had for the project when I started it.</p>
<p>It includes a lot of new features, but almost no breaking changes, which is a good sign that the project is maturing.</p>
<!-- more -->
<h2 id="admin-%2F-rest-api" tabindex="-1"><a href="http://localhost/posts/v0.14/#admin-%2F-rest-api" class="header-anchor">Admin / REST API</a></h2>
<p>You can now manage your apps using a new REST API.</p>
<p>You'll need to assign a subdomain to it:</p>
<pre><code class="language-json">// ~/smallweb/api/smallweb.json
{
    &quot;entrypoint&quot;: &quot;smallweb:api&quot;,
    &quot;private&quot;: true,
    &quot;publicRoutes&quot;: [
        &quot;/openapi.json&quot;,
        &quot;/schemas/app.schema.json&quot;,
        &quot;/schemas/config.schema.json&quot;,
    ]
}
</code></pre>
<p>Note that:</p>
<ul>
<li>There is a new kind of entrypoint, with a <code>smallweb:</code> specifier.</li>
<li>We protect the API with the <code>private</code> flag.</li>
<li>We expose some key routes to the public, like the OpenAPI schema.</li>
</ul>
<p><img src="http://localhost/img/openapi.png" alt="OpenAPI Screenshot"></p>
<p>Currently the API includes a limited set of endpoints, but it will be expanded in the future.</p>
<p>There are also some endpoints which are not documented in the OpenAPI schema:</p>
<ul>
<li>a <code>/webdav</code> endpoint to manage your files using WebDAV (this replaces <code>https://webdav.&lt;your-domain&gt;</code>)</li>
<li>json schemas for app and global config (<code>/schemas/app.schema.json</code> and <code>/schemas/config.schema.json</code>)</li>
</ul>
<p>Of course, it's quite easy to generate a client for the API using the OpenAPI schema. I recommend using <a href="https://the-guild.dev/openapi/fets/client/quick-start">fets</a>, as it does not require any code generation.</p>
<pre><code class="language-ts">import { createClient, type NormalizeOAS } from 'npm:fets'
import type openapi from 'jsr:@smallweb/openapi@0.14.0'

const client = createClient&lt;NormalizeOAS&lt;typeof openapi&gt;&gt;({
    endpoint: '&lt;your-domain&gt;',
    globalParams: {
        headers: {
            Authorization: 'Bearer &lt;your-token&gt;'
        }
    }
})

const response = await client['/v0/apps'].get()

console.log(response.json()) // typed!
</code></pre>
<p>You can generate a token for the API using the <code>smallweb token create</code> command.</p>
<pre><code class="language-sh">smallweb token create -d &quot;api token&quot; --app api
</code></pre>
<p>Note the new <code>--app</code> flag, which allows you to scope the token to a specific app (or multiple ones).</p>
<p>You can also interact with the API using the <code>smallweb</code> cli, which allows you to bypass authentication.</p>
<pre><code class="language-sh"># smallweb api -X &lt;method&gt; -H &lt;header&gt; -d &lt;data&gt; &lt;path&gt;
smallweb api -X GET /v0/apps
</code></pre>
<h2 id="automatic-ts%2Fjsx%2Ftsx-compilation-in-static-sites" tabindex="-1"><a href="http://localhost/posts/v0.14/#automatic-ts%2Fjsx%2Ftsx-compilation-in-static-sites" class="header-anchor">Automatic ts/jsx/tsx compilation in static sites</a></h2>
<p>When your app does not include a <code>main.[js,jsx,ts,tsx]</code> file, smallweb default to serve it as a static site.</p>
<p>From now on, smallweb will automatically compile your typescript and jsx files to javascript, meaning that you can just reference them in your html files.</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;
    &lt;title&gt;Document&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!-- This will be compiled to index.js --&gt;
    &lt;script src=&quot;index.ts&quot;&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Behind the scenes, it uses <a href="https://esbuild.github.io/">esbuild</a> to compile your files.</p>
<p>You can control how your jsx file are tranpiled using a pragma comment:</p>
<pre><code class="language-tsx">/** @jsxImportSource https://esm.sh/react */
import React from 'react'
import ReactDOM from 'react-dom'

ReactDOM.render(
    &lt;h1&gt;Hello, world!&lt;/h1&gt;,
    document.getElementById('root')
)
</code></pre>
<p>If your static website includes a main.ts file, you can still force the serving of static assets by creating a <code>smallweb.json</code>:</p>
<pre><code class="language-json">{
    &quot;entrypoint&quot;: &quot;smallweb:static&quot;
}
</code></pre>
<h2 id="updated-handling-of-custom-domains" tabindex="-1"><a href="http://localhost/posts/v0.14/#updated-handling-of-custom-domains" class="header-anchor">Updated handling of custom domains</a></h2>
<p>To add a custom domain in addition to the default one, you should use the new <code>customDomains</code> property in the global config.</p>
<pre><code class="language-json">// ~/.config/smallweb/config.json
{
    &quot;domain&quot;: &quot;smallweb.run&quot;,
    &quot;customDomains&quot;: {
        // map example.com to the example app
        &quot;example.com&quot;: &quot;example&quot;
    }
}
</code></pre>
<p>Custom domains also support wildcards:</p>
<pre><code class="language-json">{
    &quot;domain&quot;: &quot;smallweb.run&quot;,
    &quot;customDomains&quot;: {
        // map all subdomains of example.com to the example app
        &quot;*.example.com&quot;: &quot;example&quot;
    }
}
</code></pre>
<h2 id="removal-of-the-smallweb-terminal" tabindex="-1"><a href="http://localhost/posts/v0.14/#removal-of-the-smallweb-terminal" class="header-anchor">Removal of the smallweb terminal</a></h2>
<p>I'm not super happy with the smallweb terminal, and I think it's a bit too much of a gimmick. I might revisit it in the future, but for now I'm removing it.</p>
<p>If you were using it, you can easily recreate it as a smallweb app using <a href="https://xtermjs.org/">xterm.js</a> and the new <code>/v0/run/&lt;app&gt;</code> endpoint from the api.</p>
<h2 id="improved-logs" tabindex="-1"><a href="http://localhost/posts/v0.14/#improved-logs" class="header-anchor">Improved Logs</a></h2>
<p>You might have spotted it in the api specs, but smallweb includes some new endpoints to manage logs.</p>
<p>If you try connecting to them, you'll see a stream of json logs coming in.</p>
<p>You can easily connect this to a log management system like <a href="https://www.datadoghq.com/">datadog</a>, or <a href="https://sentry.io/">sentry</a>.</p>
<p>But if you just want to see the logs in your terminal, you can use the <code>smallweb log</code> command.</p>
<pre><code class="language-sh"># view all http requests
smallweb log http
# view all cron jobs
smallweb log cron
# view stdout/stderr output of your smallweb apps
smallweb log console
</code></pre>
<h2 id="embedded-docs" tabindex="-1"><a href="http://localhost/posts/v0.14/#embedded-docs" class="header-anchor">Embedded Docs</a></h2>
<p>Smallweb now embeds it's own documentation in the binary, meaning that you can self-host it, and have your own version of the docs that matches your version of smallweb.</p>
<pre><code class="language-json">// ~/smallweb/docs/smallweb.json
{
    &quot;entrypoint&quot;: &quot;smallweb:docs&quot;
}
</code></pre>
<h2 id="cli-changes" tabindex="-1"><a href="http://localhost/posts/v0.14/#cli-changes" class="header-anchor">CLI Changes</a></h2>
<p>I added a few new commands to the smallweb cli to help you manage your apps.</p>
<ul>
<li>A bunch of commands under <code>smallweb app</code>:
<ul>
<li><code>smallweb app create</code> to create a new app (replace <code>smallweb init</code>)</li>
<li><code>smallweb app delete</code> to delete an app</li>
<li><code>smallweb app list</code> to list all apps</li>
<li><code>smallweb app rename</code> to rename an app</li>
<li><code>smallweb app clone</code> to clone an app</li>
<li><code>smallweb app open</code> to open an app in your browser (replace <code>smallweb open</code>)</li>
</ul>
</li>
<li><code>smallweb changelog</code> to view the changelog of smallweb</li>
</ul>
<p><code>smallweb edit</code> is now deprecated, but you can easily recreate it using a <a href="https://docs.smallweb.run/guides/plugins.html">smallweb plugin</a>.</p>
<h2 id="what's-next-%3F" tabindex="-1"><a href="http://localhost/posts/v0.14/#what's-next-%3F" class="header-anchor">What's next ?</a></h2>
<p>A bunch of things!</p>
<p>Now that I have onboarded quite a few users, I've noticed that nearly everyone struggles with wiring their domain to a smallweb instance using cloudflare tunnel.</p>
<p>I'm thinking of adding a new <code>smallweb tunnel</code> command to smallweb that will be an alternative to <code>smallweb up</code>. It will create a tunnel to your smallweb instance, and provide you with a wildcard at: <code>https://*.&lt;username&gt;.smallweb.run</code>.</p>
<p>This will be completely optional, and you'll still be able to use cloudflare tunnel if you prefer.</p>
<p>Other things I'm thinking of:</p>
<ul>
<li>create an astro adapter for smallweb</li>
<li>start recording screencasts to help new users</li>
<li>create new integrations now that we have a rest api
<ul>
<li>vscode extension</li>
<li>raycast extension</li>
<li>telegram bot to manage your apps from your mobile</li>
</ul>
</li>
<li>build a library of smallweb apps. Suggestions are welcome!</li>
</ul>
<p>Also, I feel like smallweb is ready to be shared with a wider audience.
If you know of any communities that might be interested in smallweb, please let me know! I'm open to talk in conferences, meetups, or any other format.</p>
]]>
      </content:encoded>
      <pubDate>Tue, 01 Oct 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Smallweb 0.13 - Private Apps, Terminal, WebDAV, and CLI entrypoints</title>
      <link>http://localhost/posts/v0.13/</link>
      <guid isPermaLink="false">http://localhost/posts/v0.13/</guid>
      <content:encoded>
        <![CDATA[<p>Hey, It's been a while since the last release of smallweb! I've been taking a break for the month of August, but I'm back with the biggest smallweb release yet, including:</p>
<ul>
<li>Protecting private apps with authentication</li>
<li>Built-in terminal and WebDAV services</li>
<li>CLI entrypoints</li>
</ul>
<!-- more -->
<h2 id="private-apps" tabindex="-1"><a href="http://localhost/posts/v0.13/#private-apps" class="header-anchor">Private Apps</a></h2>
<p>You can now easily guard your smallweb apps behind an authentication mechanism.</p>
<ol>
<li>
<p>Add the some field to the global config (located at <code>~/.config/smallweb/config.json</code>)</p>
<pre><code class="language-json">{
    &quot;email&quot;: &quot;pomdtr@smallweb.dev&quot;
}
</code></pre>
<p>You can easily generate a new token with the <code>smallweb token</code> command.</p>
</li>
<li>
<p>Set the <code>private</code> field to true in your app config.</p>
<pre><code class="language-json">// ~/smallweb/example-app/smallweb.json
{
    &quot;private&quot;: true
}
</code></pre>
</li>
</ol>
<p>From now on, you will need to authenticate when accessing the app.</p>
<p><img src="http://localhost/img/lastlogin.png" alt="alt text"></p>
<p>The auth mechanism leverage <a href="https://lastlogin.io/">lastlogin.io</a> to provide a simple and secure authentication mechanism. I might host my own instance of lastlogin in the future, but for now, I choosed to rely on the public instance.</p>
<p>Alternatively, you can provide a token in the <code>Authorization</code> header.</p>
<pre><code class="language-sh">curl https://example-app.localhost --header &quot;Authorization: Bearer &lt;token&gt;&quot;
</code></pre>
<p>Or alternatively:</p>
<pre><code class="language-sh">curl https://&lt;token&gt;@example-app.localhost
</code></pre>
<p>To get a smallweb token, you can use the <code>smallweb token create</code> command.</p>
<pre><code class="language-sh">$ smallweb token create --description &quot;My secret token&quot;
Pj0e8hlwTolo7IoPo6ksA
</code></pre>
<h2 id="built-in-admin-apps" tabindex="-1"><a href="http://localhost/posts/v0.13/#built-in-admin-apps" class="header-anchor">Built-in Admin Apps</a></h2>
<p>This new authentication mechanism enabled me to distribute admin services as part of smallweb. In this release, there are two admin apps available:</p>
<ul>
<li><code>webdav.&lt;your-domain&gt;</code>: A WebDAV server to manage your files</li>
<li><code>cli.&lt;your-domain&gt;</code>: Allowing you to access the cli from your browser</li>
</ul>
<p>But i'm considering adding more in the future (feel free to suggest some!).</p>
<h3 id="cli-service" tabindex="-1"><a href="http://localhost/posts/v0.13/#cli-service" class="header-anchor">cli service</a></h3>
<p>You can now access the cli from your browser! This is a great way to manage a remote smallweb instance without having to ssh into it.</p>
<p>If you go to <code>cli.&lt;your-domain&gt;</code>, you will be prompted to authenticate, then be able to run any command you want.</p>
<p><img src="http://localhost/img/cli_demo.png" alt="Smallweb CLI demo"></p>
<p>The cli is protected behind the same authentication mechanism as the rest of the apps.</p>
<p><code>smallweb ls --json</code> -&gt; <code>curl -X POST 'https://cli.&lt;your-domain&gt;/ls?json' --header &quot;Authorization: Bearer my-secret-token&quot;</code></p>
<p>In a future release, the cli service might include a terminal emulator using xterm.js.</p>
<h3 id="webdav-service" tabindex="-1"><a href="http://localhost/posts/v0.13/#webdav-service" class="header-anchor">webdav service</a></h3>
<p>I've been rediscovering the power of WebDAV recently, and I wanted to make it easy to pair it with smallweb. The built-in webdav servers allows you to manage/backup your smallweb folder using any webdav client.</p>
<p>It means that smallweb can now be integrated with:</p>
<ul>
<li>All major operating systems (Windows, MacOS, Linux)</li>
<li>Web based file managers (ex: <a href="https://www.filestash.app/">https://www.filestash.app/</a>)</li>
</ul>
<p>To authenticate, you can either:</p>
<ul>
<li>Use bearer token authentication</li>
<li>Use basic authentication, and provide the token as the <strong>username</strong></li>
</ul>
<p>Currently the WebDAV server does not comes with any UI, as I was not able to find a webdav client both easily embeddable and good-looking. If you have any suggestion, feel free to reach out!</p>
<p>Having a webdav server also allows you to easily backup your smallweb apps using a tool like <a href="https://rclone.org/"><code>rclone</code></a>.</p>
<p><img src="http://localhost/img/webdav_demo.png" alt="Smallweb WebDAV demo"></p>
<h2 id="cli-entrypoints" tabindex="-1"><a href="http://localhost/posts/v0.13/#cli-entrypoints" class="header-anchor">CLI entrypoints</a></h2>
<p>Smallweb apps are required to export an object, as their default export, that contain's a <code>fetch</code> method to handle incoming requests.</p>
<pre><code class="language-ts">// ~/smallweb/example-app/main.ts
export default {
    fetch: async (request: Request) =&gt; {
        return new Response('Hello, World!');
    }
}
</code></pre>
<p>From now on, you can also register a <code>run</code> method to handle cli commands.</p>
<pre><code class="language-ts">// ~/smallweb/example-app/main.ts
export default {
    fetch: async (request: Request) =&gt; {
        return new Response('Hello, World!');
    },
    run: async (args: string[]) =&gt; {
        console.log(`Hello, ${args[0]}!`);
    }
}
</code></pre>
<p>Once you have registered a <code>run</code> method, you can run it with the <code>smallweb run</code> command.</p>
<pre><code class="language-console">$ smallweb run example-app pomdtr
Hello, pomdtr!
</code></pre>
<p>Smallweb commands run with the same permissions as the app itself. You can access stdin/stdout/stderr, not spawn subprocesses.</p>
<p>You can also access the newly created cli from the internal <code>cli.&lt;your-domain&gt;</code> service, either from your browser or using curl.</p>
<pre><code class="language-sh">curl -X POST https://cli.&lt;your-domain&gt;/run/example-app/pomdtr -H &quot;Authorization: Bearer my-secret-token&quot;
</code></pre>
<p>These cli entrypoints are also leveraged for cron tasks (which schema has been updated in this release).</p>
<pre><code class="language-json">// ~/smallweb/example-app/smallweb.json
{
    &quot;crons&quot;: [
        {
            &quot;name&quot;: &quot;say-hello-to-pomdtr&quot;,
            &quot;description&quot;: &quot;Say hello to pomdtr every day&quot;,
            &quot;schedule&quot;: &quot;0 0 * * *&quot;,
            &quot;args&quot;: [&quot;pomdtr&quot;]
        }
    ]
}
</code></pre>
<h2 id="updated-permissions" tabindex="-1"><a href="http://localhost/posts/v0.13/#updated-permissions" class="header-anchor">Updated permissions</a></h2>
<p>You used to be able to customize the permissions of a smallweb app using the <code>permissions</code> field in the app config. There was a big issue with this approach: if an app had write access to the filesystem, it could edit it's own permissions, and escalate its privileges.</p>
<p>Since I envision smallweb as a platform where user can run remote or AI generated code, I wanted to make sure that the permissions of an app are as restricted as possible.</p>
<p>In this release, app permissions are now longer customizable. Instead, each smallweb app is allowed to:</p>
<ul>
<li>read and write in its own directory</li>
<li>access the network using the fetch API</li>
<li>access the env variable defined either in the global config or in the <code>.env</code> file</li>
</ul>
<p>If you want to give you app additional permissions, you can provide it with a token has an environment variable.</p>
<pre><code class="language-sh"># ~/smallweb/example-app.env
SMALLWEB_TOKEN=my-secret-token
</code></pre>
<p>Then, you'll be able to access the cli from your app:</p>
<pre><code class="language-ts">const token = Deno.env.get(&quot;SMALLWEB_TOKEN&quot;);

const resp = await fetch(&quot;https://cli.&lt;your-domain&gt;/ls?json&quot;, {
    headers: {
        method: &quot;POST&quot;,
        Authorization: `Bearer ${token}`,
    }
});

const apps = await resp.json();
</code></pre>
<p>Or build your own smallweb editor using a <a href="https://www.npmjs.com/package/webdav">WebDAV client</a>!</p>
<h2 id="smallweb-edit-command" tabindex="-1"><a href="http://localhost/posts/v0.13/#smallweb-edit-command" class="header-anchor"><code>smallweb edit</code> command</a></h2>
<p>Use the <code>smallweb edit [app]</code> command to open an app in your default editor.</p>
<p>Of course, it integrates with the <code>cli.&lt;your-domain&gt;</code> service, allowing you to edit your apps from your browser.</p>
<h2 id="smallweb-types-command" tabindex="-1"><a href="http://localhost/posts/v0.13/#smallweb-types-command" class="header-anchor"><code>smallweb types</code> command</a></h2>
<p>With the addition of the <code>run</code> method, it can become a bit cumbersome to check that your default export is compatible with the expected smallweb schema.</p>
<p>I added a new <code>smallweb types</code> command to help you generate types hint.</p>
<p>To add the smallweb types to your project, run:</p>
<pre><code class="language-sh">smallweb types &gt; smallweb.d.ts
</code></pre>
<p>You can then reference them in your project:</p>
<pre><code class="language-ts">export default {
    fetch: async (request) =&gt; {
        return new Response('Hello, World!');
    },
    run: async (args) =&gt; {
        console.log(`Hello, ${args[0]}!`);
    }
} satisfies Smallweb.App;
</code></pre>
<h2 id="simplified-global-configuration" tabindex="-1"><a href="http://localhost/posts/v0.13/#simplified-global-configuration" class="header-anchor">Simplified Global Configuration</a></h2>
<p>The global configuration now has the following schema:</p>
<pre><code class="language-json">// ~/.config/smallweb/config.json
{
    &quot;host&quot;: &quot;127.0.0.1&quot;,
    &quot;port&quot;: 8080,
    &quot;email&quot;: &quot;pomdtr@gmail.com&quot;,
    &quot;domain&quot;: &quot;smallweb.run&quot;,
    &quot;dir&quot;: &quot;~/smallweb&quot;
}
</code></pre>
<p>All of these fields can also be provided using environment variables (ex: <code>host</code> can be provided using the <code>SMALLWEB_HOST</code> environment variable).</p>
<p>As you can see, the complex domain rooting from previous versions has been dropped. A smallweb instance maps a single wildcard domain to a single directory. If you want to manage multiple domains, feel free to run multiple instances of smallweb!</p>
<p>ex: I host two instances of smallweb on my hetzner VM (<code>smallweb.run</code> and <code>pomdtr.me</code>). To do so, I created two users (<code>smallweb.run</code> and <code>pomdtr.me</code>), and run smallweb as a service for each of them.</p>
<p>Of course, you can still attach a custom domain to a specific app by adding a <code>CNAME</code> file in the app directory, containing the domain you want to attach.</p>
<h2 id="updated-app-config" tabindex="-1"><a href="http://localhost/posts/v0.13/#updated-app-config" class="header-anchor">Updated app config</a></h2>
<p>The schema of the smallweb config was updated:</p>
<pre><code class="language-json">{
    &quot;private&quot;: true,
    &quot;entrypoint&quot;: &quot;main.ts&quot;,
    &quot;root&quot;: &quot;public&quot;,
    &quot;crons&quot;: []
}
</code></pre>
<p>We already detailed above:</p>
<ul>
<li>The addition of the <code>private</code> field</li>
<li>The removal of the <code>permissions</code> field</li>
<li>The update of the <code>crons</code> field</li>
</ul>
<p>In addition to this:</p>
<ul>
<li>the <code>serve</code> field was replaced by the <code>entrypoint</code> field. You can use it to specify which file exports the app object. If you don't provide it, smallweb will default to <code>main.[js,ts,jsx,tsx]</code>.</li>
<li>the <code>root</code> field allows you to specify the root directory of the app. The <code>entrypoint</code> file will be resolved relative to this directory.</li>
</ul>
<p>Smallweb no longer serve static files by default. If you want to serve static files, you can use the following main.ts:</p>
<pre><code class="language-ts">// ~/smallweb/example-app/main.ts
import { serveDir } from &quot;jsr:@std/http/file-server&quot;;

export default {
  fetch: (req: Request) =&gt; serveDir(req, {
    // The root directory of the app
    fsRoot: &quot;./static&quot;,
  }),
}
</code></pre>
<p>Or even simpler, add the following <code>smallweb.json</code> file:</p>
<pre><code class="language-json">{
    &quot;entrypoint&quot;: &quot;jsr:@smallweb/file-server&quot;,
    &quot;root&quot;: &quot;static&quot; // or omit it to serve the whole app directory
}
</code></pre>
]]>
      </content:encoded>
      <pubDate>Sun, 01 Sep 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Why smallweb?</title>
      <link>http://localhost/posts/why-smallweb/</link>
      <guid isPermaLink="false">http://localhost/posts/why-smallweb/</guid>
      <content:encoded>
        <![CDATA[<p>Think about the last time you worked on a local project. You probably had to:</p>
<ol>
<li>Open your project in your favorite editor</li>
<li>Start a development server</li>
<li>Open your browser and navigate to <code>http://localhost:3000</code> or any other port</li>
</ol>
<p>There are a few things that are not great about this workflow:</p>
<ol>
<li>You have to go through a few manual steps to start your project. Why can't it be running all the time?</li>
<li>Multiple projects can't run on the same port. You have to remember which project is running on which port.</li>
<li>Using <code>http://</code> is very limiting. For example, you can't install a PWA if it's not served over HTTPS.</li>
</ol>
<!-- more -->
<h2 id="why-can't-it-be-running-all-the-time%3F" tabindex="-1"><a href="http://localhost/posts/why-smallweb/#why-can't-it-be-running-all-the-time%3F" class="header-anchor">Why can't it be running all the time?</a></h2>
<p>An elegant way to address some of these issues is to use a reverse proxy like caddy, and self-signed certificates. Your proxy configuration would look something like this:</p>
<pre><code class="language-txt">website.localhost {
  tls internal {
    on_demand
  }

  reverse_proxy localhost:3000
}
</code></pre>
<p>By setting up a reverse proxy, you can access your project using <code>https://website.localhost</code> instead of <code>http://localhost:3000</code>. This is a great improvement, but it's still not perfect: you still have to manually start your project.</p>
<p>At this point you might be tempted to write a service that starts your project when you boot your computer. But this becomes cumbersome really fast, and it will end up consuming a lot of resources (each project on computer would be running all the time).</p>
<h2 id="taking-inspiration-from-serverless" tabindex="-1"><a href="http://localhost/posts/why-smallweb/#taking-inspiration-from-serverless" class="header-anchor">Taking inspiration from Serverless</a></h2>
<p>Platforms like <a href="https://vercel.com/">Vercel</a>, <a href="https://deno.com/deploy">Deno Deploy</a> or <a href="https://val.town/">Val Town</a> allow each user to host a unlimited amount of websites for free. How can they afford to do that? They don't run your code all the time. Instead, they start a new process when a request comes in, and they shut it down when it's done.</p>
<p>This sounds like a great idea, could we do the same thing, but self-hosted? This is the idea behind smallweb.</p>
<p>Instead of having all project running at all time, we will only have a single smallweb evaluation server running on port 7777.</p>
<pre><code class="language-txt">*.localhost {
  tls internal {
    on_demand
  }

  reverse_proxy localhost:7777
}
</code></pre>
<p>When a new request comes in, smallweb will map the hostname to a folder in your filesystem:</p>
<pre><code class="language-txt">website.localhost -&gt; ~/localhost/website
</code></pre>
<p>Smallweb will then start a new process, and look for a <code>main.ts</code> file in the folder. If it finds one, it will evaluate it and proxy the response back.</p>
<pre><code class="language-ts">// ~/localhost/website/main.ts

export default {
    fetch: (req: Request) =&gt; new Response(&quot;Hello, World!&quot;)
}
</code></pre>
<pre><code class="language-console">$ curl https://website.localhost
Hello, World!
</code></pre>
<h2 id="managing-servers-with-unix-commands" tabindex="-1"><a href="http://localhost/posts/why-smallweb/#managing-servers-with-unix-commands" class="header-anchor">Managing servers with unix commands</a></h2>
<p>Since hostnames are mapped to folders in your filesystem, you can use unix commands to manage your servers.</p>
<p>For example, you can clone a website by copying the folder:</p>
<pre><code class="language-sh">$ cp -r ~/localhost/website ~/localhost/website-clone
$ curl https://website-clone.localhost
Hello, World!
</code></pre>
<p>If you want to rename it, use the <code>mv</code> command. To delete it, use the <code>rm</code> command.</p>
<h2 id="running-smallweb-on-the-server" tabindex="-1"><a href="http://localhost/posts/why-smallweb/#running-smallweb-on-the-server" class="header-anchor">Running smallweb on the Server</a></h2>
<p>I've focused on the local dev experience so far, but there is nothing stopping you from running smallweb on a server.</p>
<p>In fact, this is how I host this blog, and every other <code>smallweb.run</code> websites from a 5$ Hetzner VPS.</p>
<p>With smallweb running on my server, I can host as many websites as I want, as the amount of resouces consumed depends on the amount of traffic I get, not the amount of websites I have.</p>
<p>As much my websites don't have any visitors, this is probably the right tradeoff to make 😅.</p>
]]>
      </content:encoded>
      <pubDate>Tue, 23 Jul 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Smallweb 0.12 - Publish and install flow for smallweb apps</title>
      <link>http://localhost/posts/v0.12/</link>
      <guid isPermaLink="false">http://localhost/posts/v0.12/</guid>
      <content:encoded>
        <![CDATA[<p>Smallweb 0.12 is out! And it's the first release since 0.8 where I do not feel the need to fondamentally change the routing system 😅.</p>
<p>But this is still a big release! And it even contains a few breaking changes (don't worry, they are easy to fix).</p>
<h2 id="smallweb-install%3A-a-new-convention-to-install-and-publish-smallweb-apps" tabindex="-1"><a href="http://localhost/posts/v0.12/#smallweb-install%3A-a-new-convention-to-install-and-publish-smallweb-apps" class="header-anchor"><code>smallweb install</code>: A new convention to install and publish smallweb apps</a></h2>
<p>Smallweb now includes a new <code>smallweb install</code> command to install smallweb apps from the web.</p>
<p>Smallweb apps work on top of github repositories. When you run</p>
<pre><code class="language-sh">smallweb install pomdtr/example-app ~/localhost/smallweb-app
</code></pre>
<p>smallweb will clone the <code>pomdtr/example-app</code> repository in the <code>~/localhost/smallweb-app</code> folder.</p>
<!-- more -->
<p>If the repository contains a <code>smallweb</code> branch, smallweb will checkout this branch. Otherwise, it will checkout the <code>main</code> branch.</p>
<p>This convention is really similar to how github pages work, and you can even repurposes github pages actions to build your smallweb app (see <a href="https://github.com/pomdtr/smallweb-blog/blob/main/.github/workflows/deploy.yml#L24">how this blog is built</a> for an example).</p>
<p>Once an app is installed, you can use the <code>git</code> cli to manage them. For example, you can run <code>git pull</code> to update the app to the latest version, or <code>git checkout &lt;hash&gt;</code> to rollback to a previous version. Take a look to the <a href="https://github.com/pomdtr/smallweb-puller">pomdtr/smallweb-puller repository</a> for a simple way to trigger an app update from the ouside.</p>
<p>If you create a smallweb app, make sure to add the <code>smallweb-app</code> topic to your repository.</p>
<h2 id="smallweb-init-now-support-custom-templates" tabindex="-1"><a href="http://localhost/posts/v0.12/#smallweb-init-now-support-custom-templates" class="header-anchor"><code>smallweb init</code> now support custom templates</a></h2>
<p>The <code>smallweb init</code> was reworked to allow users to define custom templates from github. Smallweb templates are just github repositories with a <code>smallweb-template</code> topic.</p>
<p>The new command usage is:</p>
<pre><code class="language-ts">smallweb init [dir] [--template &lt;repo&gt;]
</code></pre>
<p>When you run <code>smallweb init example --template pomdtr/smallweb-template-astro</code>, smallweb will download the content of the <code>pomdtr/smallweb-template-astro</code> repository in the <code>example</code> folder (without creating a <code>.git</code> folder).</p>
<h2 id="crons-jobs-are-now-defined-as-http-requests" tabindex="-1"><a href="http://localhost/posts/v0.12/#crons-jobs-are-now-defined-as-http-requests" class="header-anchor">Crons jobs are now defined as HTTP requests</a></h2>
<p>Crons uses to be defined as shell commands:</p>
<pre><code class="language-json">{
    &quot;crons&quot;: [
        {
            &quot;schedule&quot;: &quot;0 0 * * *&quot;,
            &quot;command&quot;: &quot;deno&quot;,
            &quot;args&quot;: [&quot;run&quot;, &quot;--allow-net&quot;, &quot;https://example.com/cron.ts&quot;]
        }
    ]
}
</code></pre>
<p>This had a few limitations:</p>
<ul>
<li>crons did not respect the permissions of the app</li>
<li>getting access to the same Deno KV instance was tricky in some cases</li>
</ul>
<p>For these reasons (and in preparation for the upcoming hosted version of smallweb), crons are now defined as HTTP requests:</p>
<pre><code class="language-json">// smallweb.json
{
    &quot;crons&quot;: [
        {
            &quot;schedule&quot;: &quot;0 0 * * *&quot;,
            &quot;path&quot;: &quot;/refresh&quot;,
        }
    ]
}
</code></pre>
<p>This is the exact same API as <a href="https://vercel.com/guides/how-to-setup-cron-jobs-on-vercel">Vercel's cron</a>, so you can refer to their documentation for some examples of how to use it.</p>
<p>This also remove the need for the <code>smallweb cron trigger</code> command (as you can just go to <code>https://&lt;app&gt;/refresh</code> to trigger the cron).</p>
<p><code>smallweb cron list</code> was moved to <code>smallweb crons</code>.</p>
<h2 id="smallweb-open-has-new-flags" tabindex="-1"><a href="http://localhost/posts/v0.12/#smallweb-open-has-new-flags" class="header-anchor"><code>smallweb open</code> has new flags</a></h2>
<p>Smallweb open now supports opening both using the app name or dir:</p>
<pre><code class="language-sh"># open the react.localhost app
smallweb open --app react.localhost
# open the located at ~/localhost/react
smallweb open --dir ~/localhost/react
# open the current directory
smallweb open
</code></pre>
<h2 id="deno-kv-is-now-scoped-to-the-hostname" tabindex="-1"><a href="http://localhost/posts/v0.12/#deno-kv-is-now-scoped-to-the-hostname" class="header-anchor">Deno KV is now scoped to the hostname</a></h2>
<p>If you map multiple domains to the same dir:</p>
<pre><code class="language-json">{
    &quot;*-kv.smallweb.run&quot;: &quot;~/kv&quot;
}
</code></pre>
<p>And uses the default KV instance:</p>
<pre><code class="language-ts">// ~/kv/main.ts

const kv = await Deno.openKv()
</code></pre>
<p><code>example-kv.smallweb.run</code> and <code>another-kv.smallweb.run</code> will not share the same KV instance. This behavior will allow some cool new usecases (ex: preview deployments with distinct KV instances).</p>
<p>If you want to share a db between multiple hostnames, you can always specify a kv path in your code:</p>
<pre><code class="language-ts">const kv = await Deno.openKv({ path: &quot;./kv.db&quot; })
</code></pre>
<h2 id="what's-next%3F" tabindex="-1"><a href="http://localhost/posts/v0.12/#what's-next%3F" class="header-anchor">What's next?</a></h2>
<p>I really feel smallweb is in a good state right now, and I want to grow its community. I just bought a new mic and plan to record some videos to showcase smallweb features on YouTube and Twitter.</p>
<p>Improved logs are still a priority. I want to move logs to their own file instead of using stderr/stdout, and allow you to filter them by app/time by storing them as JSON lines.</p>
<p>Now that we have an efficient way to distribute and install apps, I want to port more apps to smallweb. I hope you'll help me with this one!</p>
<p>And finally, I plan to resume the work on smallweb sister project, smallbrowser.</p>
]]>
      </content:encoded>
      <pubDate>Tue, 23 Jul 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Smallweb 0.11 - Global config and new routing</title>
      <link>http://localhost/posts/v0.11/</link>
      <guid isPermaLink="false">http://localhost/posts/v0.11/</guid>
      <content:encoded>
        <![CDATA[<h2 id="a-new-(optional)-global-config" tabindex="-1"><a href="http://localhost/posts/v0.11/#a-new-(optional)-global-config" class="header-anchor">A new (optional) global config</a></h2>
<p>You can now configure the smallweb host, port, and other global settings in a <code>~/.config/smallweb/config.json</code> file.</p>
<p>Here is the implicit default configuration if the file does not exist:</p>
<pre><code class="language-json">{
    &quot;host&quot;: &quot;127.0.0.1&quot;,
    &quot;port&quot;: 7777,
    &quot;domains&quot;: {
        &quot;*.localhost&quot;: &quot;~/localhost/*&quot;
    },
    &quot;env&quot;: {
        &quot;DENO_TLS_CA_STORE&quot;: &quot;system&quot;
    }
}
</code></pre>
<!-- more -->
<p>Smallweb also supports the following environment variables:</p>
<ul>
<li><code>SMALLWEB_HOST</code></li>
<li><code>SMALLWEB_PORT</code></li>
</ul>
<h2 id="config-based-routing" tabindex="-1"><a href="http://localhost/posts/v0.11/#config-based-routing" class="header-anchor">Config Based Routing</a></h2>
<p>You might have noticed the new <code>domains</code> key in the global config.</p>
<p>It's part of a new routing system that allows you to map domains to folders in your filesystem.</p>
<p>For example, you can map:</p>
<ul>
<li><code>pomdtr.me</code> to <code>~/pomdtr.me</code>: All requests to <code>pomdtr.me</code> will be served from the <code>~/pomdtr.me</code> folder.</li>
<li><code>*.smallweb.run</code> to <code>~/smallweb.run/*</code>: All requests to <code>&lt;app&gt;.smallweb.run</code> will be served from the <code>~/smallweb.run/&lt;app&gt;</code> folder.</li>
<li><code>*.example.me</code> to <code>~/example.com</code>: All requests to <code>*.example.me</code> will be served from the <code>~/example.com</code> folder.</li>
</ul>
<p>The config is live-reloaded, so you can change it on the fly.</p>
<p>I hope this new system will allows advanced users to handle more advanced routing scenarios, while keeping the simplicity of the original system.</p>
<p>This change also means that the notion of a &quot;smallweb root&quot; is now deprecated. You can put your smallweb apps anywhere in your filesystem.</p>
<h2 id="smallweb-open" tabindex="-1"><a href="http://localhost/posts/v0.11/#smallweb-open" class="header-anchor"><code>smallweb open</code></a></h2>
<p>Smallweb open now works on top of directories.</p>
<p>To open the app from the current directory in your browser, you can run:</p>
<pre><code class="language-sh">smallweb open .
</code></pre>
<p>Or do something like this if you have a blog stored at <code>~/localhost/blog</code>:</p>
<pre><code class="language-sh">smallweb open ~/localhost/blog
</code></pre>
<h2 id="smallweb-create--%3E-smallweb-init" tabindex="-1"><a href="http://localhost/posts/v0.11/#smallweb-create--%3E-smallweb-init" class="header-anchor"><code>smallweb create</code> -&gt; <code>smallweb init</code></a></h2>
<p><code>smallweb create</code> was replaced by <code>smallweb init</code>.</p>
<p>If you want <code>smallweb init</code>, you'll get an interactive prompt to create a new project.</p>
<p>You can also skip the prompts by passing the appropriate args and flags.</p>
<pre><code class="language-sh">smallweb init ~/localhost/hono-app --template hono
</code></pre>
]]>
      </content:encoded>
      <pubDate>Wed, 17 Jul 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Smallweb 0.10 - Cron jobs are here!</title>
      <link>http://localhost/posts/v0.10/</link>
      <guid isPermaLink="false">http://localhost/posts/v0.10/</guid>
      <content:encoded>
        <![CDATA[<h2 id="smallweb-now-supports-cron-jobs" tabindex="-1"><a href="http://localhost/posts/v0.10/#smallweb-now-supports-cron-jobs" class="header-anchor">Smallweb now supports cron jobs</a></h2>
<p>Cron jobs were one of the key features missing from smallweb.
You can now defines them from the <code>smallweb.json[c]</code> file.</p>
<pre><code class="language-json">{
  &quot;crons&quot;: [
    {
      &quot;name&quot;: &quot;my-cron-job&quot;,
      &quot;schedule&quot;: &quot;0 0 * * *&quot;,
      &quot;command&quot;: &quot;echo&quot;,
      &quot;args&quot;: [&quot;hello world!&quot;]
    }
  ]
}
</code></pre>
<!-- more -->
<p>Cron jobs are defined by a name, a schedule, a command, and optional arguments.</p>
<p>The minimum schedule is <code>* * * * *</code> which means every minute. <a href="https://crontab.guru/">crontab.guru</a> is a great tool to help you define your schedule.</p>
<p>Additionally, two new commands were added to manage cron jobs:</p>
<ul>
<li><code>smallweb cron list</code> to list all cron jobs</li>
<li><code>smallweb cron trigger</code> to trigger a cron job manually</li>
</ul>
<p>Make sure to setup the completions for your shell to get the full experience.</p>
<p>More information can be found in the <a href="https://docs.smallweb.run/guides/cron.html">documentation</a>.</p>
<h2 id="smallweb-create-is-now-interactive" tabindex="-1"><a href="http://localhost/posts/v0.10/#smallweb-create-is-now-interactive" class="header-anchor"><code>smallweb create</code> is now interactive</a></h2>
<p>You can now just run <code>smallweb create</code> to initialize a new project.</p>
<p>It will ask you a few questions and generate a new project for you.
You can skip the questions by passing the <code>--name</code> and <code>--template</code> flags.</p>
<h2 id="what's-next%3F" tabindex="-1"><a href="http://localhost/posts/v0.10/#what's-next%3F" class="header-anchor">What's next?</a></h2>
<p>I want to focus on improving the logs experience in the next release.</p>
<p>Currently, all logs are grouped together, and there is no way to filter between:</p>
<ul>
<li>system logs (ex: http requests)</li>
<li>application logs (ex: stdout/stderr)</li>
</ul>
<p>The user should also be able to filter logs by domain, or application.</p>
<p>In order to achieve this, I'm thinking of emitting logs as json to stdout, and converting them to human readable format in the cli.</p>
<p>I also plan to work on:</p>
<ul>
<li>a landing page for smallweb</li>
<li>a demo video showcasing the features</li>
</ul>
]]>
      </content:encoded>
      <pubDate>Sat, 13 Jul 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Smallweb 0.9 - Improved Routing</title>
      <link>http://localhost/posts/v0.9/</link>
      <guid isPermaLink="false">http://localhost/posts/v0.9/</guid>
      <content:encoded>
        <![CDATA[<h2 id="updated-routing" tabindex="-1"><a href="http://localhost/posts/v0.9/#updated-routing" class="header-anchor">Updated Routing</a></h2>
<p>After a lot of feedback shared by community, the routing was rethinked from the
ground up. Thanks everyone for sharing your thoughts!</p>
<p>Here is what your smallweb root folder (which defaults to <code>~/smallweb</code>) should
now look like:</p>
<pre><code class="language-txt">~/smallweb/
├── localhost
│   ├── example
│   │   └── main.ts
│   └── react
│       └── main.ts
├── pomdtr.me
│   └── www
│       └── main.ts
└── smallweb.run
    ├── www
    │   └── main.ts
    ├── assets
    │   └── main.ts
    └── readme
        └── main.ts
</code></pre>
<!-- more -->
<p>The first level of subfolder is the apex domain, and the second one is the
subdomain.</p>
<ul>
<li><code>https://assets.smallweb.run</code> will be routed to
<code>~/smallweb/smallweb.run/assets/</code></li>
<li><code>react.localhost</code> will be routed to <code>~/smallweb/localhost/react/</code></li>
</ul>
<p>Request targeting the apex domain will be automatically redirected to the <code>www</code>
subdomain.</p>
<p>You can read more about the design process in the
<a href="http://localhost/blog/routing-design.md">dedicated blog post</a>.</p>
<h2 id="smallweb-list" tabindex="-1"><a href="http://localhost/posts/v0.9/#smallweb-list" class="header-anchor">smallweb list</a></h2>
<p>The smallweb dump command was renamed to <code>smallweb list</code>.</p>
<p>Smallweb list supports both human and machine readable output (with a <code>--json</code>
flag).</p>
<p>You can filter by domain using the <code>--domain</code> flag.</p>
<h2 id="smallweb-open" tabindex="-1"><a href="http://localhost/posts/v0.9/#smallweb-open" class="header-anchor">smallweb open</a></h2>
<p>The <code>smallweb open</code> command can now open smallweb websites, even when your
current directory is not the root of a smallweb app.</p>
<p>Just pass the app name to the command:</p>
<pre><code class="language-sh">smallweb open react.localhost
</code></pre>
<p>The command provides completions, make sure to set them properly. You can get
shell specific instructions using the <code>smallweb help completion</code> command.</p>
]]>
      </content:encoded>
      <pubDate>Fri, 12 Jul 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Rethinking Smallweb Routing</title>
      <link>http://localhost/posts/routing-design/</link>
      <guid isPermaLink="false">http://localhost/posts/routing-design/</guid>
      <content:encoded>
        <![CDATA[<p>Smallweb <code>v0.8.0</code> was released yesterday, and it included the first smallweb
breaking change.</p>
<blockquote>
<p>The <code>~/www</code> convention was dropped, the defaut folder is now <code>~/smallweb</code></p>
<p>In addition to this change, the folder should now be named after the hostname:</p>
<ul>
<li>example.smallweb.run =&gt; ~/smallweb/example.smallweb.run/</li>
<li>pomdtr.me =&gt; ~/smallweb/pomdtr.me/</li>
<li>example.localhost =&gt; ~/smallweb/example.localhost/</li>
</ul>
</blockquote>
<p>This change was not really well received:</p>
<blockquote>
<p>I'm not a fan of the new hostname folder convention. It feels noisy.</p>
<p>I'm also a bit frustrated by this change, and this is my main gripe with it
too. And this &quot;ugliness&quot; is (for me) exacerbated by the fact that there's
going to be a lot of repetition if all my smallweb apps are <code>&lt;app&gt;.localhost</code>.
I would prefer a convention like <code>~/smallweb/localhost/example</code> mapping to
<code>example.localhost</code></p>
</blockquote>
<p>In this post, I'll try to address:</p>
<ul>
<li>the drawbacks of the previous convention</li>
<li>the options I've considered</li>
</ul>
<!-- more -->
<h2 id="why-a-change-was-needed" tabindex="-1"><a href="http://localhost/posts/routing-design/#why-a-change-was-needed" class="header-anchor">Why a change was needed</a></h2>
<p>The smallweb routing system was originally designed for a single usecase:
hosting a unlimited amount of websites locally, using <code>*.localhost</code> domains.</p>
<p>The convention was to:</p>
<ul>
<li>store all of your website in the smallweb root (<code>~/www</code> by default)</li>
<li>use the folder name has the subdomain</li>
</ul>
<p>So <code>~/www/example/</code> would be mapped to <code>https://example.localhost</code>.</p>
<p>As the project expanded, new usecases emerged for smallweb: hosting smallweb on
a raspberrypi, or even on a VPS from hetzner/digital ocean...</p>
<p>And the intitial design hold quite well with these usecases. You would just
assign a domain to your device (ex: <code>*.pomdtr.me</code>), and <code>~/www/example/</code> would
map to <code>https://example.pomdtr.me</code>.</p>
<p>But what if I wanted to assign multiple domains to a single machine ? If I route
both <code>*.pomdtr.me</code> and <code>*.smallweb.run</code> to my machine, <code>~/www/example</code> will
match both <code>https://example.pomdtr.me</code> and <code>https://example.smallweb.run</code>. This
is probably not what the user want in most cases.</p>
<h2 id="options-i've-considered" tabindex="-1"><a href="http://localhost/posts/routing-design/#options-i've-considered" class="header-anchor">Options I've considered</a></h2>
<p>Let's say we want to manage the following websites using smallweb.</p>
<ul>
<li><code>https://smallweb.run</code></li>
<li><code>https://readme.smallweb.run</code></li>
<li><code>https://assets.smallweb.run</code></li>
<li><code>https://pomdtr.me</code></li>
<li><code>https://example.localhost</code></li>
<li><code>https://react.localhost</code></li>
</ul>
<p>We'll assume that all of these websites are defined in a single <code>main.ts</code>.</p>
<h3 id="option-1%3A-not-using-the-folder-name" tabindex="-1"><a href="http://localhost/posts/routing-design/#option-1%3A-not-using-the-folder-name" class="header-anchor">Option 1: Not using the folder name</a></h3>
<p>We could just allow arbitrary folder names, and just use a CNAME at the root of
the app, specifying the domain name.</p>
<pre><code class="language-txt">assets.smallweb.run
</code></pre>
<p>It sounds like a fine solution, but it means that every smallweb website would
need to include it. I really want single-file websites to be able to exist, and
I feel like file based routing is a core feature of smallweb, so I did not go
with this option.</p>
<h3 id="option-2%3A-using-a-nested-structure" tabindex="-1"><a href="http://localhost/posts/routing-design/#option-2%3A-using-a-nested-structure" class="header-anchor">Option 2: Using a Nested structure</a></h3>
<pre><code class="language-txt">/
├── localhost
│   ├── example
│   │   └── main.ts
│   └── react
│       └── main.ts
├── me
│   └── pomdtr
│       └── main.ts
└── run
    └── smallweb
        ├── main.ts
        ├── assets
        │   └── main.ts
        └── readme
            └── main.ts
</code></pre>
<p>Of course, this is not acceptable. If we look at the <code>/run/smallweb</code> folder, we
can see that it contains both:</p>
<ul>
<li>the code of the <code>https://smallweb.run</code> homepage at his root.</li>
<li>the code of <code>readme</code> and <code>assets</code> subdomains</li>
</ul>
<p>If we used a git repository to manage each of those websites, this would quickly
become a mess.</p>
<p>To counter this, we can add a convention: if the request target a root domain,
it will be automatically redirected to the <code>www</code> domain.</p>
<pre><code class="language-txt">/
├── localhost
│   ├── example
│   │   └── main.ts
│   └── react
│       └── main.ts
├── me
│   └── pomdtr
│       └── www
│           └── main.ts
└── run
    └── smallweb
        ├── assets
        │   └── main.ts
        ├── readme
        │   └── main.ts
        └── www
            └── main.ts
</code></pre>
<p>This looks better! However, it still feels like we have some uncessary nesting.</p>
<p>For example, the <code>/run</code> folder only has one subfolder: <code>/run/smallweb</code>. Folders
are supposed to group related websites, but websites sharing the same TLD
probably have nothing in common.</p>
<p>Even worse, <code>pomdtr.me</code> requires 3 (!!!) level of nesting: <code>/me/pomdtr/www</code>.</p>
<h3 id="option-3%3A-2-level-structure" tabindex="-1"><a href="http://localhost/posts/routing-design/#option-3%3A-2-level-structure" class="header-anchor">Option 3: 2-level structure</a></h3>
<p>Instead of splitting on <code>.</code>, we'll use the apex domain as the first level of
subfolder, and the subdomain as the second one.</p>
<p>If a request target the apex domain, will automatically redirect it to the <code>www</code>
subdomain.</p>
<pre><code class="language-txt">/
├── localhost
│   ├── example
│   │   └── main.ts
│   └── react
│       └── main.ts
├── pomdtr.me
│   └── www
│       └── main.ts
└── smallweb.run
    ├── www
    │   └── main.ts
    ├── assets
    │   └── main.ts
    └── readme
        └── main.ts
</code></pre>
<p>We still have some uncessary nesting (<code>pomdtr/www</code>), but we get meaningful
groups in exchange.</p>
<p>Here the folder structure kind of reflect the process of updating DNS records in
cloudflare.</p>
<h3 id="option-4%3A-flat-structure" tabindex="-1"><a href="http://localhost/posts/routing-design/#option-4%3A-flat-structure" class="header-anchor">Option 4: Flat structure</a></h3>
<p>Let's drop the nesting, and use the domain name as the folder name:</p>
<pre><code class="language-txt">/
├── assets.smallweb.run
│   └── main.ts
├── example.localhost
│   └── main.ts
├── pomdtr.me
│   └── main.ts
├── react.localhost
│   └── main.ts
├── readme.smallweb.run
│   └── main.ts
└── smallweb.run
    └── main.ts
</code></pre>
<p>Using the domain name as the folder looks kind of ugly, but it avoid the nested
folders problem entirely. One big advantage of this architecture is that you can
create a new website from a git repository by just doing:</p>
<pre><code class="language-sh">git clone &lt;repo-url&gt; &lt;hostname&gt;
</code></pre>
<p>My main gripe with it (outside of the noisy folder names), is that related
websites appears in different places in the file tree (ex: <code>react.localhost</code> and
<code>example.localhost</code> are not next to each others).</p>
<p>We can fix it by reversing the folder names:</p>
<pre><code class="language-txt">/
├── localhost.example
│   └── main.ts
├── localhost.react
│   └── main.ts
├── me.pomdtr
│   └── main.ts
├── run.smallweb
│   └── main.ts
├── run.smallweb.assets
│   └── main.ts
└── run.smallweb.readme
    └── main.ts
</code></pre>
<p>I quite like this compromise, but I'm not sure it would address the noisyness
reported by the community.</p>
<h2 id="what-do-you-think-%3F" tabindex="-1"><a href="http://localhost/posts/routing-design/#what-do-you-think-%3F" class="header-anchor">What do you think ?</a></h2>
<p>Here are the two options I'm considering as default:</p>
<ol>
<li>2-level structure</li>
<li>Reversed Flat structure</li>
</ol>
<p>Writing this article, I've come to gain more appreciation of the two
level-structure, as it mirrors the process of setting up DNS record in your
domain registrar. However, the reversed flat structure is far more
straightforward, which is a plus in my book.</p>
<p>I wonder if we should support both options (remix-style).</p>
<p>I would love to hear your thoughts on all of this. Make sure to join the
<a href="https://discord.gg/36jsj3rS">discord channel</a> if you want your voice to be
heard.</p>
]]>
      </content:encoded>
      <pubDate>Thu, 11 Jul 2024 00:00:00 GMT</pubDate>
    </item>
  </channel>
</rss>