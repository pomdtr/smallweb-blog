<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:wfw="http://wellformedweb.org/CommentAPI/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:sy="http://purl.org/rss/1.0/modules/syndication/" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" version="2.0">
  <channel>
    <title>Smallweb Blog</title>
    <link>http://localhost/</link>
    <atom:link href="http://localhost/feed.xml" rel="self" type="application/rss+xml"/>
    <description>The latest new from Smallweb</description>
    <lastBuildDate>Mon, 22 Jul 2024 22:03:08 GMT</lastBuildDate>
    <language>en</language>
    <generator>Lume v2.2.2</generator>
    <item>
      <title>Smallweb 0.11 - Global config and new routing</title>
      <link>http://localhost/posts/v0.11/</link>
      <guid isPermaLink="false">http://localhost/posts/v0.11/</guid>
      <content:encoded>
        <![CDATA[<h2 id="a-new-(optional)-global-config" tabindex="-1"><a href="http://localhost/posts/v0.11/#a-new-(optional)-global-config" class="header-anchor">A new (optional) global config</a></h2>
<p>You can now configure the smallweb host, port, and other global settings in a <code>~/.config/smallweb/config.json</code> file.</p>
<p>Here is the implicit default configuration if the file does not exist:</p>
<pre><code class="language-json">{
    &quot;host&quot;: &quot;127.0.0.1&quot;,
    &quot;port&quot;: 7777,
    &quot;domains&quot;: {
        &quot;*.localhost&quot;: &quot;~/localhost/*&quot;
    },
    &quot;env&quot;: {
        &quot;DENO_TLS_CA_STORE&quot;: &quot;system&quot;
    }
}
</code></pre>
<!-- more -->
<p>Smallweb also supports the following environment variables:</p>
<ul>
<li><code>SMALLWEB_HOST</code></li>
<li><code>SMALLWEB_PORT</code></li>
</ul>
<h2 id="config-based-routing" tabindex="-1"><a href="http://localhost/posts/v0.11/#config-based-routing" class="header-anchor">Config Based Routing</a></h2>
<p>You might have noticed the new <code>domains</code> key in the global config.</p>
<p>It's part of a new routing system that allows you to map domains to folders in your filesystem.</p>
<p>For example, you can map:</p>
<ul>
<li><code>pomdtr.me</code> to <code>~/pomdtr.me</code>: All requests to <code>pomdtr.me</code> will be served from the <code>~/pomdtr.me</code> folder.</li>
<li><code>*.smallweb.run</code> to <code>~/smallweb.run/*</code>: All requests to <code>&lt;app&gt;.smallweb.run</code> will be served from the <code>~/smallweb.run/&lt;app&gt;</code> folder.</li>
<li><code>*.example.me</code> to <code>~/example.com</code>: All requests to <code>*.example.me</code> will be served from the <code>~/example.com</code> folder.</li>
</ul>
<p>The config is live-reloaded, so you can change it on the fly.</p>
<p>I hope this new system will allows advanced users to handle more advanced routing scenarios, while keeping the simplicity of the original system.</p>
<p>This change also means that the notion of a &quot;smallweb root&quot; is now deprecated. You can put your smallweb apps anywhere in your filesystem.</p>
<h2 id="smallweb-open" tabindex="-1"><a href="http://localhost/posts/v0.11/#smallweb-open" class="header-anchor"><code>smallweb open</code></a></h2>
<p>Smallweb open now works on top of directories.</p>
<p>To open the app from the current directory in your browser, you can run:</p>
<pre><code class="language-sh">smallweb open .
</code></pre>
<p>Or do something like this if you have a blog stored at <code>~/localhost/blog</code>:</p>
<pre><code class="language-sh">smallweb open ~/localhost/blog
</code></pre>
<h2 id="smallweb-create--%3E-smallweb-init" tabindex="-1"><a href="http://localhost/posts/v0.11/#smallweb-create--%3E-smallweb-init" class="header-anchor"><code>smallweb create</code> -&gt; <code>smallweb init</code></a></h2>
<p><code>smallweb create</code> was replaced by <code>smallweb init</code>.</p>
<p>If you want <code>smallweb init</code>, you'll get an interactive prompt to create a new project.</p>
<p>You can also skip the prompts by passing the appropriate args and flags.</p>
<pre><code class="language-sh">smallweb init ~/localhost/hono-app --template hono
</code></pre>
]]>
      </content:encoded>
      <pubDate>Wed, 17 Jul 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Smallweb 0.10 - Cron jobs are here!</title>
      <link>http://localhost/posts/v0.10/</link>
      <guid isPermaLink="false">http://localhost/posts/v0.10/</guid>
      <content:encoded>
        <![CDATA[<h2 id="smallweb-now-supports-cron-jobs" tabindex="-1"><a href="http://localhost/posts/v0.10/#smallweb-now-supports-cron-jobs" class="header-anchor">Smallweb now supports cron jobs</a></h2>
<p>Cron jobs were one of the key features missing from smallweb.
You can now defines them from the <code>smallweb.json[c]</code> file.</p>
<pre><code class="language-json">{
  &quot;crons&quot;: [
    {
      &quot;name&quot;: &quot;my-cron-job&quot;,
      &quot;schedule&quot;: &quot;0 0 * * *&quot;,
      &quot;command&quot;: &quot;echo&quot;,
      &quot;args&quot;: [&quot;hello world!&quot;]
    }
  ]
}
</code></pre>
<!-- more -->
<p>Cron jobs are defined by a name, a schedule, a command, and optional arguments.</p>
<p>The minimum schedule is <code>* * * * *</code> which means every minute. <a href="https://crontab.guru/">crontab.guru</a> is a great tool to help you define your schedule.</p>
<p>Additionally, two new commands were added to manage cron jobs:</p>
<ul>
<li><code>smallweb cron list</code> to list all cron jobs</li>
<li><code>smallweb cron trigger</code> to trigger a cron job manually</li>
</ul>
<p>Make sure to setup the completions for your shell to get the full experience.</p>
<p>More information can be found in the <a href="https://docs.smallweb.run/guides/cron.html">documentation</a>.</p>
<h2 id="smallweb-create-is-now-interactive" tabindex="-1"><a href="http://localhost/posts/v0.10/#smallweb-create-is-now-interactive" class="header-anchor"><code>smallweb create</code> is now interactive</a></h2>
<p>You can now just run <code>smallweb create</code> to initialize a new project.</p>
<p>It will ask you a few questions and generate a new project for you.
You can skip the questions by passing the <code>--name</code> and <code>--template</code> flags.</p>
<h2 id="what's-next%3F" tabindex="-1"><a href="http://localhost/posts/v0.10/#what's-next%3F" class="header-anchor">What's next?</a></h2>
<p>I want to focus on improving the logs experience in the next release.</p>
<p>Currently, all logs are grouped together, and there is no way to filter between:</p>
<ul>
<li>system logs (ex: http requests)</li>
<li>application logs (ex: stdout/stderr)</li>
</ul>
<p>The user should also be able to filter logs by domain, or application.</p>
<p>In order to achieve this, I'm thinking of emitting logs as json to stdout, and converting them to human readable format in the cli.</p>
<p>I also plan to work on:</p>
<ul>
<li>a landing page for smallweb</li>
<li>a demo video showcasing the features</li>
</ul>
]]>
      </content:encoded>
      <pubDate>Sat, 13 Jul 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Smallweb 0.9 - Improved Routing</title>
      <link>http://localhost/posts/v0.9/</link>
      <guid isPermaLink="false">http://localhost/posts/v0.9/</guid>
      <content:encoded>
        <![CDATA[<h2 id="updated-routing" tabindex="-1"><a href="http://localhost/posts/v0.9/#updated-routing" class="header-anchor">Updated Routing</a></h2>
<p>After a lot of feedback shared by community, the routing was rethinked from the
ground up. Thanks everyone for sharing your thoughts!</p>
<p>Here is what your smallweb root folder (which defaults to <code>~/smallweb</code>) should
now look like:</p>
<pre><code class="language-txt">~/smallweb/
├── localhost
│   ├── example
│   │   └── main.ts
│   └── react
│       └── main.ts
├── pomdtr.me
│   └── www
│       └── main.ts
└── smallweb.run
    ├── www
    │   └── main.ts
    ├── assets
    │   └── main.ts
    └── readme
        └── main.ts
</code></pre>
<!-- more -->
<p>The first level of subfolder is the apex domain, and the second one is the
subdomain.</p>
<ul>
<li><code>https://assets.smallweb.run</code> will be routed to
<code>~/smallweb/smallweb.run/assets/</code></li>
<li><code>react.localhost</code> will be routed to <code>~/smallweb/localhost/react/</code></li>
</ul>
<p>Request targeting the apex domain will be automatically redirected to the <code>www</code>
subdomain.</p>
<p>You can read more about the design process in the
<a href="http://localhost/blog/routing-design.md">dedicated blog post</a>.</p>
<h2 id="smallweb-list" tabindex="-1"><a href="http://localhost/posts/v0.9/#smallweb-list" class="header-anchor">smallweb list</a></h2>
<p>The smallweb dump command was renamed to <code>smallweb list</code>.</p>
<p>Smallweb list supports both human and machine readable output (with a <code>--json</code>
flag).</p>
<p>You can filter by domain using the <code>--domain</code> flag.</p>
<h2 id="smallweb-open" tabindex="-1"><a href="http://localhost/posts/v0.9/#smallweb-open" class="header-anchor">smallweb open</a></h2>
<p>The <code>smallweb open</code> command can now open smallweb websites, even when your
current directory is not the root of a smallweb app.</p>
<p>Just pass the app name to the command:</p>
<pre><code class="language-sh">smallweb open react.localhost
</code></pre>
<p>The command provides completions, make sure to set them properly. You can get
shell specific instructions using the <code>smallweb help completion</code> command.</p>
]]>
      </content:encoded>
      <pubDate>Fri, 12 Jul 2024 00:00:00 GMT</pubDate>
    </item>
    <item>
      <title>Rethinking Smallweb Routing</title>
      <link>http://localhost/posts/routing-design/</link>
      <guid isPermaLink="false">http://localhost/posts/routing-design/</guid>
      <content:encoded>
        <![CDATA[<p>Smallweb <code>v0.8.0</code> was released yesterday, and it included the first smallweb
breaking change.</p>
<blockquote>
<p>The <code>~/www</code> convention was dropped, the defaut folder is now <code>~/smallweb</code></p>
<p>In addition to this change, the folder should now be named after the hostname:</p>
<ul>
<li>example.smallweb.run =&gt; ~/smallweb/example.smallweb.run/</li>
<li>pomdtr.me =&gt; ~/smallweb/pomdtr.me/</li>
<li>example.localhost =&gt; ~/smallweb/example.localhost/</li>
</ul>
</blockquote>
<p>This change was not really well received:</p>
<blockquote>
<p>I'm not a fan of the new hostname folder convention. It feels noisy.</p>
<p>I'm also a bit frustrated by this change, and this is my main gripe with it
too. And this &quot;ugliness&quot; is (for me) exacerbated by the fact that there's
going to be a lot of repetition if all my smallweb apps are <code>&lt;app&gt;.localhost</code>.
I would prefer a convention like <code>~/smallweb/localhost/example</code> mapping to
<code>example.localhost</code></p>
</blockquote>
<p>In this post, I'll try to address:</p>
<ul>
<li>the drawbacks of the previous convention</li>
<li>the options I've considered</li>
</ul>
<!-- more -->
<h2 id="why-a-change-was-needed" tabindex="-1"><a href="http://localhost/posts/routing-design/#why-a-change-was-needed" class="header-anchor">Why a change was needed</a></h2>
<p>The smallweb routing system was originally designed for a single usecase:
hosting a unlimited amount of websites locally, using <code>*.localhost</code> domains.</p>
<p>The convention was to:</p>
<ul>
<li>store all of your website in the smallweb root (<code>~/www</code> by default)</li>
<li>use the folder name has the subdomain</li>
</ul>
<p>So <code>~/www/example/</code> would be mapped to <code>https://example.localhost</code>.</p>
<p>As the project expanded, new usecases emerged for smallweb: hosting smallweb on
a raspberrypi, or even on a VPS from hetzner/digital ocean...</p>
<p>And the intitial design hold quite well with these usecases. You would just
assign a domain to your device (ex: <code>*.pomdtr.me</code>), and <code>~/www/example/</code> would
map to <code>https://example.pomdtr.me</code>.</p>
<p>But what if I wanted to assign multiple domains to a single machine ? If I route
both <code>*.pomdtr.me</code> and <code>*.smallweb.run</code> to my machine, <code>~/www/example</code> will
match both <code>https://example.pomdtr.me</code> and <code>https://example.smallweb.run</code>. This
is probably not what the user want in most cases.</p>
<h2 id="options-i've-considered" tabindex="-1"><a href="http://localhost/posts/routing-design/#options-i've-considered" class="header-anchor">Options I've considered</a></h2>
<p>Let's say we want to manage the following websites using smallweb.</p>
<ul>
<li><code>https://smallweb.run</code></li>
<li><code>https://readme.smallweb.run</code></li>
<li><code>https://assets.smallweb.run</code></li>
<li><code>https://pomdtr.me</code></li>
<li><code>https://example.localhost</code></li>
<li><code>https://react.localhost</code></li>
</ul>
<p>We'll assume that all of these websites are defined in a single <code>main.ts</code>.</p>
<h3 id="option-1%3A-not-using-the-folder-name" tabindex="-1"><a href="http://localhost/posts/routing-design/#option-1%3A-not-using-the-folder-name" class="header-anchor">Option 1: Not using the folder name</a></h3>
<p>We could just allow arbitrary folder names, and just use a CNAME at the root of
the app, specifying the domain name.</p>
<pre><code class="language-txt">assets.smallweb.run
</code></pre>
<p>It sounds like a fine solution, but it means that every smallweb website would
need to include it. I really want single-file websites to be able to exist, and
I feel like file based routing is a core feature of smallweb, so I did not go
with this option.</p>
<h3 id="option-2%3A-using-a-nested-structure" tabindex="-1"><a href="http://localhost/posts/routing-design/#option-2%3A-using-a-nested-structure" class="header-anchor">Option 2: Using a Nested structure</a></h3>
<pre><code class="language-txt">/
├── localhost
│   ├── example
│   │   └── main.ts
│   └── react
│       └── main.ts
├── me
│   └── pomdtr
│       └── main.ts
└── run
    └── smallweb
        ├── main.ts
        ├── assets
        │   └── main.ts
        └── readme
            └── main.ts
</code></pre>
<p>Of course, this is not acceptable. If we look at the <code>/run/smallweb</code> folder, we
can see that it contains both:</p>
<ul>
<li>the code of the <code>https://smallweb.run</code> homepage at his root.</li>
<li>the code of <code>readme</code> and <code>assets</code> subdomains</li>
</ul>
<p>If we used a git repository to manage each of those websites, this would quickly
become a mess.</p>
<p>To counter this, we can add a convention: if the request target a root domain,
it will be automatically redirected to the <code>www</code> domain.</p>
<pre><code class="language-txt">/
├── localhost
│   ├── example
│   │   └── main.ts
│   └── react
│       └── main.ts
├── me
│   └── pomdtr
│       └── www
│           └── main.ts
└── run
    └── smallweb
        ├── assets
        │   └── main.ts
        ├── readme
        │   └── main.ts
        └── www
            └── main.ts
</code></pre>
<p>This looks better! However, it still feels like we have some uncessary nesting.</p>
<p>For example, the <code>/run</code> folder only has one subfolder: <code>/run/smallweb</code>. Folders
are supposed to group related websites, but websites sharing the same TLD
probably have nothing in common.</p>
<p>Even worse, <code>pomdtr.me</code> requires 3 (!!!) level of nesting: <code>/me/pomdtr/www</code>.</p>
<h3 id="option-3%3A-2-level-structure" tabindex="-1"><a href="http://localhost/posts/routing-design/#option-3%3A-2-level-structure" class="header-anchor">Option 3: 2-level structure</a></h3>
<p>Instead of splitting on <code>.</code>, we'll use the apex domain as the first level of
subfolder, and the subdomain as the second one.</p>
<p>If a request target the apex domain, will automatically redirect it to the <code>www</code>
subdomain.</p>
<pre><code class="language-txt">/
├── localhost
│   ├── example
│   │   └── main.ts
│   └── react
│       └── main.ts
├── pomdtr.me
│   └── www
│       └── main.ts
└── smallweb.run
    ├── www
    │   └── main.ts
    ├── assets
    │   └── main.ts
    └── readme
        └── main.ts
</code></pre>
<p>We still have some uncessary nesting (<code>pomdtr/www</code>), but we get meaningful
groups in exchange.</p>
<p>Here the folder structure kind of reflect the process of updating DNS records in
cloudflare.</p>
<h3 id="option-4%3A-flat-structure" tabindex="-1"><a href="http://localhost/posts/routing-design/#option-4%3A-flat-structure" class="header-anchor">Option 4: Flat structure</a></h3>
<p>Let's drop the nesting, and use the domain name as the folder name:</p>
<pre><code class="language-txt">/
├── assets.smallweb.run
│   └── main.ts
├── example.localhost
│   └── main.ts
├── pomdtr.me
│   └── main.ts
├── react.localhost
│   └── main.ts
├── readme.smallweb.run
│   └── main.ts
└── smallweb.run
    └── main.ts
</code></pre>
<p>Using the domain name as the folder looks kind of ugly, but it avoid the nested
folders problem entirely. One big advantage of this architecture is that you can
create a new website from a git repository by just doing:</p>
<pre><code class="language-sh">git clone &lt;repo-url&gt; &lt;hostname&gt;
</code></pre>
<p>My main gripe with it (outside of the noisy folder names), is that related
websites appears in different places in the file tree (ex: <code>react.localhost</code> and
<code>example.localhost</code> are not next to each others).</p>
<p>We can fix it by reversing the folder names:</p>
<pre><code class="language-txt">/
├── localhost.example
│   └── main.ts
├── localhost.react
│   └── main.ts
├── me.pomdtr
│   └── main.ts
├── run.smallweb
│   └── main.ts
├── run.smallweb.assets
│   └── main.ts
└── run.smallweb.readme
    └── main.ts
</code></pre>
<p>I quite like this compromise, but I'm not sure it would address the noisyness
reported by the community.</p>
<h2 id="what-do-you-think-%3F" tabindex="-1"><a href="http://localhost/posts/routing-design/#what-do-you-think-%3F" class="header-anchor">What do you think ?</a></h2>
<p>Here are the two options I'm considering as default:</p>
<ol>
<li>2-level structure</li>
<li>Reversed Flat structure</li>
</ol>
<p>Writing this article, I've come to gain more appreciation of the two
level-structure, as it mirrors the process of setting up DNS record in your
domain registrar. However, the reversed flat structure is far more
straightforward, which is a plus in my book.</p>
<p>I wonder if we should support both options (remix-style).</p>
<p>I would love to hear your thoughts on all of this. Make sure to join the
<a href="https://discord.gg/36jsj3rS">discord channel</a> if you want your voice to be
heard.</p>
]]>
      </content:encoded>
      <pubDate>Thu, 11 Jul 2024 00:00:00 GMT</pubDate>
    </item>
  </channel>
</rss>